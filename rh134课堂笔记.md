| 第一天                     | 第二天               | 第三天              | 第四天                    | 第五天       |
| :------------------------- | -------------------- | :------------------ | ------------------------- | ------------ |
| 1、提高命令行生产率        | 5、管理SELinux安全性 | 8、实施高级存储功能 | 11、管理网络安全firewalld | 13、容器介绍 |
| 2、计划将来的任务          | 6、管理基本存储      | 9、访问网络附加存储 | 12、安装rhel              | 14、总复习   |
| 3、调优系统性能            | 7、管理逻辑卷        | 10、控制启动过程    |                           |              |
| 4、使用ACL控制对文件的访问 |                      |                     |                           |              |

```bash
设置课程
我们目标是把培训环境课程调整至rh134
rht-clearcourse 0      清除当前课程内容
rht-setcourse rh134    设置为rh134课程

如何设置为rh294
rht-clearcourse 0      清除当前课程内容
rht-setcourse rh294    


```



# 第一章 提高命令行生产率

### 脚本：

| 系统    |                                  |      |
| ------- | -------------------------------- | ---- |
| Windows | *.bat,*.cmd,.vbd                 |      |
| Linux   | #！/bin/bash ,  chmod +x file.sh |      |

#### 指定命令解释器

```
#!/bin/bash
```

#### 执行Bash Shell

脚本中需要书写解释器#!/bin/bash，脚本内容可以是linux命令。linux系统可以通过/etc/shells查看支持的shell类型。

[root@foundation0 /]# cat /etc/shells 
/bin/sh
/bin/bash
/usr/bin/sh
/usr/bin/bash
/usr/bin/tmux
/bin/tmux



[root@foundation0 /]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

[root@foundation0 /]# mkdir /root/bin

[root@foundation0 /]# vim /root/bin/shell.sh

#!/bin/bash

date

[root@foundation0 /]# chmod  +x  /root/bin/shell.sh

[root@foundation0 /]# cd /tmp

[root@foundation0 /]# shell.sh



### \, '' , ""，``,$()

```bash
# echo {1..10}
# echo $(seq 1 10)
[root@servera /]# echo hello    
hello
[root@servera /]# echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
[root@servera /]# echo \$PATH
$PATH
[root@servera /]# echo '$PATH'
$PATH
[root@servera /]# echo "$PATH"
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

在shell中设置一个变量暂时使用
[root@servera /]# var=`date`
[root@servera /]# var=$(date)
[root@servera /]# echo 'to day $var'
to day $var
[root@servera /]# echo "to day $var"
to day Fri Mar  6 16:32:50 CST 2020
[root@servera /]# echo "to day \$var"
to day $var

[root@servera /]# touch $(date +%H%M%S).txt

取消一个变量
[root@servera /]# unset var

$ echo $HOSTNAME
$ ssh root@172.25.254.250 'touch /tmp/$HOSTNAME'
$ ssh root@172.25.254.250 'ls /tmp'
$ ssh root@172.25.254.250 "touch /home/$HOSTNAME"
$ ssh root@172.25.254.250 'ls -l /home'
```

### 基本用法

```bash
[root@foundation0 bin]# first.sh 
hello world


[root@foundation0 bin]# sh first.sh 
hello world
[root@foundation0 bin]# bash first.sh 
hello world
[root@foundation0 bin]# source first.sh 
hello world
[root@foundation0 bin]# . first.sh    
hello world

```

### ``,$()

```bash
`命令`
$(命令)
whoami
echo whoami
echo `whoami`
echo $(whoami)
date
echo `date`
man date
date +%y%m%d
date +%Y%m%d
date +%Y-%m-%d
echo $(date +%Y-%m-%d)
touch $(date +%Y-%m-%d).txt
ls
tar -zcvf $(date +%Y-%m-%d).tar.gz /etc/
ls
cd /

既然可以通过``和$()的结果，通过echo来通过标准输出打印到屏幕上，那么我们也可以将其应用到脚本。
vim os.current
#!/bin/bash
  
echo -e "User:\t" $(whoami)
echo -e "HOST:\t" `hostname`
echo -e "ipv4:\t" $(ip a s enp1s0 | awk '/inet / {print $2}')
echo -e "Memory:\t" $(free -h | awk '/Mem/ {print $2}') 
echo -e "Disk:\t" $(df -ht xfs | awk '/dev/ {print $4}')

chmod +x os.current 
./os.current 
scp os.current root@servera:/
ssh root@servera

sh os.current
bash os.current
source os.current
. os.current


```

### 使用循环更高效的运行命令

for语句

在脚本中使用退出代码

使用运算符执行测试

if语句

#### for语句

```bash
for variable in list
	do
		command variable
done

for i in 1 2 3
	do 
		echo $i
done


[root@servera ~]# echo {1..10}
1 2 3 4 5 6 7 8 9 10
[root@servera ~]# echo $(seq 1 10)
1 2 3 4 5 6 7 8 9 10

[root@servera ~]# for i in host1 host2 host3;do echo $i;done
host1
host2
host3
[root@servera ~]# for i in host{1..3};do echo $i;done
host1
host2
host3
[root@servera ~]# cd /opt/
[root@servera opt]# ls
[root@servera opt]# touch file{1..3}
[root@servera opt]# ls
file1  file2  file3
[root@servera opt]# for i in file*;do ls $i;done
file1
file2
file3



[root@servera ~]# echo ${HOSTNAME}O
servera.lab.example.comO
[root@servera ~]# echo $HOSTNAME\O
servera.lab.example.comO

vim user.sh
#!/bin/bash
for i in {1..10};do
        useradd user$i 2> /dev/null
        echo P@ssw0rd${i}a | passwd --stdin user$i
done


sh user.sh



```

#### 在脚本中使用退出代码

```bash
#!/bin/bash
echo "hello world"
exit 0


#!/bin/bash
echo "hello world"
exit 1
```



使用运算符执行测试

### test, []

```bash
test 0 -ne 1 
   36  echo $?
   37  test 0 -ge 0 
   38  echo $?
   39  test 0 -ge 1 
   40  echo $?
   41  test 8 -gt 4
   42  echo $?
   43  [ 0 -ge 0 ]
   44  echo $?

-eq	等于则为真
-ne	不等于则为真
-gt	大于则为真
-lt	小于则为真
-ge	大于等于则为真
-le	小于等于则为真

字符串判断
= ==  != -z -n
```

### exit ,if  elif  else 

```bash
if [ 条件 ]
  then
       声明
fi
 
一、
vim tj.sh
#!/bin/bash
if [ 0 -ge 0 ];then
        echo ok
fi

二、
vim cjk.sh
#!/bin/bash
if [ -e /file1 ];then
        echo one
        exit 10
fi

三、
#!/bin/bash
if [ -e /file1 ];then
        echo one
        exit 10
else
        echo two
        exit 20
fi

四、
#!/bin/bash
if [ -e /file1 ];then
        echo one
        exit 10
elif [ -e /opt/file1 ];then
        echo two
        exit 20
else
        echo tree
        exit 30
fi



练习：
创建一个添加用户的脚本
在system1上创建一个脚本，名为/root/makeusers，此脚本能实现为系统system1创建本地用户，并且这些用户的用户名来自一个包含列表的文件。用户满足下列要求：
（1）	此脚本要求提供一个参数，此参数就是包含用户名列表的文件
（2）	如果没有提供参数，此脚本应该给出下面的提示信息 Usage: /root/makeusers userfile然后退出并返回相应的值
（3）	如果提供一个不存在的文件名，此脚本应该给出下面的提示信息 Input file not found然后退出并返回相应的值
（4）	创建的用户登录shell为/bin/false
（5）	此脚本不需要为用户设置密码

[root@servera ~]# cat /root/userfile
testuser1
testuser2
testuser3


#!/bin/bash
if [ $# -lt 1 ];then
        echo "Usage: $0 userfile"
        exit 1
elif [ ! -f $1 ];then
        echo "Input file not found"
        exit 1
else
        for i in `cat $1`;do
                /usr/sbin/useradd -s /bin/false $i
        done
fi


[root@servera ~]# ./makeusers /userfile.txt


```

### $0，$1，$2..$9 ,$# 系统变量

```bash
$0，$1，$2..$9 ,$# 
#!/bin/bash
  
ping -c $2 172.25.254.$1

echo '$0: ' $0
echo '$1: ' $1
echo '$2: ' $2
echo '$3: ' $3
echo '$#: ' $#

[root@servera ~]# chmod +x ping.sh
[root@servera ~]# ./ping.sh 254 5
PING 172.25.254.254 (172.25.254.254) 56(84) bytes of data.
64 bytes from 172.25.254.254: icmp_seq=1 ttl=63 time=3.02 ms
64 bytes from 172.25.254.254: icmp_seq=2 ttl=63 time=0.976 ms
64 bytes from 172.25.254.254: icmp_seq=3 ttl=63 time=1.03 ms
64 bytes from 172.25.254.254: icmp_seq=4 ttl=63 time=1.09 ms
64 bytes from 172.25.254.254: icmp_seq=5 ttl=63 time=2.16 ms

--- 172.25.254.254 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 12ms
rtt min/avg/max/mdev = 0.976/1.654/3.015/0.808 ms
$0:  ./ping.sh
$1:  254
$2:  5
$3: 
$#:  2


$@
$？
$$
______

使用if语句创建用户
1、创建用户列表文件
[root@servera /]# cat user_list.txt 
tom
harry 
frem



```

### grep,cut

```bash
grep root /etc/passwd
grep root /etc/passwd | cut  -d :  -f 1,3-5          
grep root /etc/passwd | cut -c 1,3-5                 
grep ^root /etc/passwd
grep nologin$ /etc/passwd
cat -n /etc/passwd									 
grep -n ^# /etc/selinux/config 	
vim /etc/selinux/config 
grep ^$ /etc/selinux/config 
grep ^$ /etc/selinux/config  | wc -l
grep -n ^$ /etc/selinux/config  
grep -v ^$ /etc/selinux/config 
grep ^# /etc/selinux/config 
grep -v ^# /etc/selinux/config 


cat /etc/selinux/config | grep -v ^# | grep -v ^$


[root@foundation0 /]# grep ng /usr/share/xml/iso-codes/iso_639_3.xml > /1.txt
[root@foundation0 /]# 
[root@foundation0 /]# 
[root@foundation0 /]# grep ^$ /1.txt
[root@foundation0 /]# grep ^$ /1.txt | wc -l
额外：
# grep -e root -e 0 /etc/passwd       grep -e可以在一个文件内单独匹配多个参数
root:x:0:0:root:/root:/bin/bash
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
# grep -E 'root|0' /etc/passwd

[root@foundation0 ~]# grep 'kiosk|root' /etc/passwd
[root@foundation0 ~]# egrep 'kiosk|root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
kiosk:x:1000:1000::/home/kiosk:/bin/bash
[root@foundation0 ~]# grep  -E 'kiosk|root' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
kiosk:x:1000:1000::/home/kiosk:/bin/bash

grep -A
grep -B
grep -C
head -5 /etc/passwd
  137  head -5 /etc/passwd > /opt/passwd.tst
  138  ls
  139  cat passwd.tst 
  140  grep -A 2 daemon
  141  grep -A 2 daemon passwd.tst 
  142  grep -B  2 daemon passwd.tst 
  143  grep -C  2 daemon passwd.tst 
```

#### 正则表达式

```bash
[root@foundation0 /]# cat testfile 
cat
cot
cut
dog
concatenate
dogma
category
educated
boondoggle
vindication
chilidog
aacat
caaaaaaaat

匹配行首和行尾
[root@foundation0 /]# grep ^cat testfile 
cat
category 
[root@foundation0 /]# grep cat$ testfile 
cat
aacat
[root@foundation0 /]# grep ^cat$ testfile 
cat

向正则表达式中添加通配符和倍数
1、. 匹配换行符以外的任何“单”个字符
[root@servera opt]# grep c.t testfile 

2、选择[]内的一个字符。搜索结果应为c开头、中间a或o或u、结尾t
[root@servera opt]# grep c[aou]t testfile     ca*t cot cut

3、倍数通常与统配符一起使用，*表示匹配前一个表达式的0个或多个选项
[root@servera opt]# grep c[aou]*t testfile 

4、倍数通常与统配符一起使用，如.*  这将匹配任何以c开头，后面跟0个或多个字符,t结尾
[root@servera opt]# grep c.*t testfile 


```



# 第二章 Linux计划任务

临时计划任务at

周期性计划任务cron



### at

```bash
[root@servera /]# rpm -qa at
at-3.1.20-11.el8.x86_64
[root@servera /]# systemctl status atd.service 

[root@servera /]# rpm -qc at
/etc/at.deny
/etc/pam.d/atd
/etc/sysconfig/atd

at 选项 参数

创建
[root@servera /]# at 13:49
warning: commands will be executed using /bin/sh
at> touch /at.txt
at> <EOT>          ctrl+d退出

3分钟后执行
echo "date" >> /home/student/myjob.txt | at now +3min
明天17:20点执行echo
at 17:20 tomorrow
at> echo hello
三天后下午5:10分执行/bin/ls
at 5:10pm+3days
at> /bin/ls


查看
[root@servera /]# atq
作业编号  执行日期和时间             队列a			运行作业所有者
7	     Sun Mar  8 13:51:00 2020 a         	 root
[root@servera /]# at -l

查看任务内容
[root@servera /]# at -c 7
删除
[root@servera /]# at -d 9
[root@servera /]# atrm 8

监控任务
[root@servera ~]# watch atq      ctrl+c 退出监控模式

```

### crontab

```bash
[root@servera /]# systemctl status crond.service 
[root@servera /]# systemctl  enable crond
[root@servera /]# systemctl is-enabled crond
[root@servera /]# systemctl enable --now crond


[root@servera /]# rpm -qa cron
[root@servera /]# rpm -qa | grep cron
cronie-anacron-1.5.2-2.el8.x86_64
cronie-1.5.2-2.el8.x86_64
crontabs-1.11-16.20150630git.el8.noarch
[root@servera /]#　rpm -qc crontabs
/etc/crontab

crontab 选项 
-e	编辑计划任务	crontab -e
-u	指定用户  crontab -u student -e
-r	删除
-l	列出

*       *       *       *       *       command
分		时     日 	 月       周		 任务内容
0-59    0-23   1-31    1-12    0-7

每年2月2日上午9点执行echo  hello
0       9       2       2       *       echo hello

每天3到6点 第2分 执行一个脚本/root/1.sh
2	3-6 *	*	* /bin/sh /root/1.sh

每两个小时的第2分钟，执行一个脚本/root/1.sh
2	*/2   *	*	*	 /bin/sh /root/1.sh

每年７月的第１天和第５天，两点２分，执行一个脚本/root/1.sh
2	2   1,5	7	*	 /bin/sh /root/1.sh

配置cron任务，每隔2分钟运行logger “Ex200 in progress”，以harry用户身份运行
[root@servera /]# id harry
[root@servera /]# crontab -u harry -e
[root@servera /]# crontab -u harry -l  (也可以ｓｕ切换到任务用户，运行crontab -l)
*/2 	*	*	* 	*    /usr/bin/logger “Ex200 in progress” 

删除某条可以crontab -e 进去编辑
删除用户的所有任务
crontab -r 	

 vim /etc/cron.deny  限制用户使用crond服务
```

### 管理临时文件

rhel6 tmpwatch

systemd-tmpfiles

```bash
[root@servera /]# systemctl status systemd-tmpfiles-setup
[root@servera /]# rpm -qf /usr/lib/tmpfiles.d/tmp.conf 
systemd-239-13.el8.x86_64

cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d/
cd /etc/tmpfiles.d/
vim tmp.conf
q /tmp 1777 root root 5d
systemd-tmpfiles --clean /etc/tmpfiles.d/tmp.conf 




清理临时文件
创建一个存放临时文件的目录，并且设置相应权限/run/momentary 0700 root root
[root@servera /]# vim /etc/tmpfiles.d/momentary.conf
d /run/momentary 0700 root root 30s
创建存放临时文件目录
[root@servera /]# systemd-tmpfiles --create /etc/tmpfiles.d/momentary.conf 
[root@servera /]# ll /run/momentary/ -d
drwx------. 2 root root 40 Mar  8 15:08 /run/momentary/
在目录中创建一个文件叫做mom.txt，此文件模拟临时文件
[root@servera /]# touch /run/momentary/mom.txt
[root@servera /]# sleep 30
[root@servera /]# ll /run/momentary/mom.txt 
-rw-r--r--. 1 root root 0 Mar  8 15:08 /run/momentary/mom.txt
输入清除临时文件命令，清除所有的临时文件
[root@servera /]# systemd-tmpfiles --clean /etc/tmpfiles.d/momentary.conf 
[root@servera /]# ll /run/momentary/mom.txt 
ls: cannot access '/run/momentary/mom.txt': No such file or directory


对tmp做一些临时文件管理，设置临时文件管理时间
cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d/
q /tmp 1777 root root 5d
[root@servera /]# systemd-tmpfiles --clean /etc/tmpfiles.d/tmp.conf
```

# 第三章 系统性能调优

### tuned 

```bash
tuned 
[root@servera tmp]# yum install -y tuned
[root@servera tmp]# systemctl status tuned

[root@servera tmp]# systemctl enable --now tuned
[root@servera tmp]# systemctl is-enabled tuned
enabled
查看
[root@servera tmp]# tuned-adm list
[root@servera tmp]# tuned-adm recommend   查看系统推荐的
[root@servera tmp]# tuned-adm profile virtual-guest 修改优化方案为virtual-guest
[root@servera tmp]# tuned-adm off 关闭优化



练习：修改为系统推荐的优化方案
[root@servera tmp]# tuned-adm recommend   查看系统推荐的
virtual-guest
[root@servera tmp]# tuned-adm profile virtual-guest 
[root@servera tmp]# tuned-adm active 
Current active profile: virtual-guest

方法二：--系统--Performance Profile 修改--修改后点 change profile

```

# 第四章 ACL访问控制列表

### setfacl，getfacl

```bash
查看文件是否设置了acl
[root@servera /]# ll os.current 
-rwxrwxr-x+ 1 root root 246 Mar  8 10:14 os.current    有+加号

setfacl
选项
-m 设置后面的acl权限给文件（目录）使用
-x 删除acl，某条
-b 删除所有
-R  递归

getfacl
-R

acl可以针对：
user
group
mask


-m
设置
[root@servera /]# man setfacl 搜索EXAMPLES 复制例子
[root@servera /]# setfacl -m u:harry:rwx os.current 
[root@servera /]# 
[root@servera /]# ll os.current 
[root@servera /]# setfacl -m u:lisa:--- os.current
-rwxrwxrwx+ 1 root root 246 Mar  8 10:14 os.current
查看
[root@servera /]# getfacl os.current 
# file: os.current
# owner: root
# group: root
user::rwx
user:harry:rwx
user:lisa:---
group::r-x
mask::rwx
other::r-x


[root@servera /]# setfacl -m g:east:rwx acltest.txt 
[root@servera /]# setfacl -m m:rw- acltest.txt 
[root@servera /]# getfacl acltest.txt 
# file: acltest.txt
# owner: root
# group: root

user::rw-
group::r--
group:east:rwx			#effective:rw-
mask::rw-
other::r--

user和group权限只有和mask权限重叠时才生效


-x

[root@servera /]# setfacl -x g:east acltest.txt 
[root@servera /]# setfacl -x m: acltest.txt 
[root@servera /]# setfacl -x u:harry os.current 
[root@servera /]# getfacl os.current 
# file: os.current
# owner: root
# group: root
user::rwx
user:lisa:---
group::r-x
mask::r-x
other::r-x

-b
[root@servera /]# setfacl -b os.current


-R ，-Rb
[root@servera opt]# mkdir acldir
[root@servera opt]# touch acldir/acl.txt
[root@servera opt]# ls acldir/
acl.txt
[root@servera opt]# setfacl -Rm u:harry:rwx acldir/
[root@servera opt]# getfacl -R acldir/
# file: acldir/
# owner: root
# group: root
user::rwx
user:harry:rwx
group::r-x
mask::rwx
other::r-x

# file: acldir//acl.txt
# owner: root
# group: root
user::rw-
user:harry:rwx
group::r--
mask::rwx
other::r--

[root@servera opt]# setfacl -Rb acldir/
[root@servera opt]# getfacl -R acldir/
# file: acldir/
# owner: root
# group: root
user::rwx
group::r-x
other::r-x

# file: acldir//acl.txt
# owner: root
# group: root
user::rw-
group::r--
other::r--

修改文件原本的所属组权限
setfacl -m g::perms file

[root@servera opt]# setfacl -m g::r acldir/
[root@servera opt]# getfacl acldir/
# file: acldir/
# owner: root
# group: root
user::rwx
user:tom:rwx
group::r--
mask::rwx
other::r-x


ACL备份及恢复
setfacl -Rm u:harry:rwx acldir/
getfacl -R acldir/
getfacl -R acldir/ > /acl.bak   将权限备份到/acl.bak文件中


setfacl -Rb acldir/    清除，模拟丢失
getfacl -R acldir/    此时没有权限

setfacl --restore=/acl.bak  恢复
getfacl -R acldir/   再查看权限已经恢复

恢复方法二: 将getfacl输出作为setfac的输入
getfacl -R /folder/ > file1
setfacl --set-file=file1 /folder/


练习：
配置 /var/tmp/fstab 权限
[root@servera /]# cp /etc/fstab /var/tmp
[root@servera /]# ll /var/tmp/fstab 
-rw-r--r--. 1 root root 427 Mar  8 16:40 /var/tmp/fstab
[root@servera /]# id natasha
id: ‘natasha’: no such user
[root@servera /]# id harry
uid=1014(harry) gid=1014(harry) groups=1014(harry)
[root@servera /]# useradd natasha
[root@servera /]# 
[root@servera /]# setfacl -m u:natasha:rw /var/tmp/fstab 
[root@servera /]# setfacl -m u:harry:--- /var/tmp/fstab 
[root@servera /]# getfacl /var/tmp/fstab 
getfacl: Removing leading '/' from absolute path names
# file: var/tmp/fstab
# owner: root
# group: root
user::rw-
user:harry:---
user:natasha:rw-
group::r--
mask::rw-
other::r--

```

# 第五章 管理SELinux

**一、什么是selinux**

SELinux 全称 Security Enhanced Linux (安全强化 Linux),是美国国家安全局2000年以 GNU GPL 发布，是 MAC (Mandatory Access Control，强制访问控制系统)的一个实现，目的在于明确的指明某个进程可以访问哪些资源(文件、网络端口等)。强制访问控制系统 的用途在于增强系统抵御 0-Day 攻击(利用尚未公开的漏洞实现的攻击行为)的能力。所以它不是网络防火墙或 ACL 的替代品，在用途上也 不重复。在目前的大多数发行版中，已经默认在内核集成了SELinux。

|  ID  |            |                         | SELinux                                                      |
| :--: | ---------- | ----------------------- | ------------------------------------------------------------ |
|  1   | Filesystem | chmod, chown, setfacl   | semanage fcontext ... restorecon ... chcon ... touch /.autorelabel |
|  2   | Service    | vim /etc/*.conf         | setsebool -P ...                                             |
|  3   | Firewall   | firewall-cmd ...        | semanage port ...                                            |
|  4   | SELinux    | vim /etc/selinux/config |                                                              |

**二、selinux实现原理**

1、SELinux是用于确定哪个进程可以访问哪些文件、目录和端口的一组安全规则。每个文件、进程、目录、端口都具有专门的安全标签，称为SELinux上下文。上下文是一个名称SELinux策略使用它来确定某个进程是否能访问文件、目录或端口。除非显示规则授予访问权限，否则，在默认情况下，策略不允许任何交互。如果没有允许规则，则不允许访问。

2、selinux标签具有多种上下文、用户、角色、类型、安全级别。策略会根据type字段即类型上下文来指定自己的规则。

unconfined_u   :object_r:   httpd_sys_content_t:    s0        /var/www/html/file2

用户		        角色                类型                               级别      文件

3、因为selinux限制方式是允许哪个进程访问哪个文件、目录、端口。所以：

比如web服务器的进程类型上下文是httpd_t。而/var/www/html的上下文通常是httpd_sys_content_t。如果策略库中（semanage fcontext -l）有此策略，并且是允许的关系，则可以通过apache进程进行访问/var/www/html，否则不允许。

又或者/tmp和/var/tmp中的上下文类型是tmp_t ，httpd_t只允许访问和httpd。。。。t的上下文，所以httpd_t的进程不允许访问tmp_t上下文的文件。

apache的上下文是httpd_t，mariadb的上下文是mysqld_t，每个不同应用都有自己的上下文类型，默认规则中只能访问和自己上下文相同类型的文件。

#### 如何查看上下文

```bash
进程：
ps auxZ

[root@servera ~]# ps auxZ | grep httpd
system_u:system_r:httpd_t:s0    root      1971  0.0  1.2 273800 10496 ?        Ss   04:58   0:00 /usr/sbin/httpd -DFOREGROUND
system_u:system_r:httpd_t:s0    apache    1972  0.0  0.9 286016  7972 ?        S    04:58   0:00 /usr/sbin/httpd -DFOREGROUND
system_u:system_r:httpd_t:s0    apache    1973  0.0  1.5 1474944 13436 ?       Sl   04:58   0:00 /usr/sbin/httpd -DFOREGROUND
system_u:system_r:httpd_t:s0    apache    1974  0.0  1.3 1343816 11388 ?       Sl   04:58   0:00 /usr/sbin/httpd -DFOREGROUND
system_u:system_r:httpd_t:s0    apache    1975  0.0  1.3 1343816 11388 ?       Sl   04:58   0:00 /usr/sbin/httpd -DFOREGROUND
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 root 5475 0.0  0.1 221860 980 pts/0 R+ 05:04   0:00 grep --color=auto httpd


文件：
ls -Z
[root@servera ~]# ls -dZ /var/www/html/
system_u:object_r:httpd_sys_content_t:s0 /var/www/html/

```

### 三、临时开启或关闭selinux

```bash
[root@servera ~]# setenforce   设置
usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]
[root@servera ~]# setenforce 1
[root@servera ~]# getenforce  查看
Enforcing

```

### 永久开启或关闭selinux状态

```bash
[root@servera ~]# vim /etc/selinux/config
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=enforcing

修改后，重启操作系统生效
```

### 四、继承特性

继承：

1、在父目录下创建文件会继承selinux上下文touch

2、cp 

不继承：

创建了文件并且移动mv，会保留原来的父目录上下文关系

复制时cp  -a（rp） ，也会保留之前的上下文关系

```bash
<pre>[root@servera ~]# cd /tmp/
[root@servera tmp]# touch file{1..3}
[root@servera tmp]# ls -Z /tmp/file*
unconfined_u:object_r:user_tmp_t:s0 /tmp/file1  unconfined_u:object_r:user_tmp_t:s0 /tmp/file2  unconfined_u:object_r:user_tmp_t:s0 /tmp/file3
[root@servera tmp]# ls -Z /tmp/file*
[root@servera tmp]# cp /tmp/file1 /var/www/html/
[root@servera tmp]# cp -a /tmp/file2 /var/www/html/
[root@servera tmp]# mv /tmp/file3 /var/www/html/
[root@servera tmp]# cd /var/www/html/
[root@servera html]# ls -Z *
unconfined_u:object_r:httpd_sys_content_t:s0 file1           unconfined_u:object_r:user_tmp_t:s0 file3
         unconfined_u:object_r:user_tmp_t:s0 file2
[root@servera html]# touch /var/www/html/file4
[root@servera html]# ll -Z /var/www/html/file4
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:08 /var/www/html/file4
</pre>

[root@servera html]# restorecon -Rv /var/www/html/


```

### 五、定义selinux默认文件上下文规则

semanage fcontext 显示、修改上下文数据库

restorecon 设置默认上下文

（/.*）? 表示匹配后跟任何数量的/。相当于递归到下级目录。

chcon 设置上下文关系

```bash
semanage fcontext 
-a 	添加   添加至数据库
-d	删除
-l	查看
-t	指定上下文
-m  修改

restorecon
-v  显示修改标签内容
-R  递归

[root@servera html]# semanage fcontext -l | grep /var/www
/var/www(/.*)?                                     all files          system_u:object_r:httpd_sys_content_t:s0 
[root@servera html]# ls
file1  file2  file3  file4
[root@servera html]# ll -Z file*
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:08 file1
-rw-r--r--. 1 root root unconfined_u:object_r:user_tmp_t:s0          0 Apr 10 05:07 file2
-rw-r--r--. 1 root root unconfined_u:object_r:user_tmp_t:s0          0 Apr 10 05:07 file3
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:08 file4
[root@servera html]# restorecon -Rv /var/www/html/
Relabeled /var/www/html/file2 from unconfined_u:object_r:user_tmp_t:s0 to unconfined_u:object_r:httpd_sys_content_t:s0
Relabeled /var/www/html/file3 from unconfined_u:object_r:user_tmp_t:s0 to unconfined_u:object_r:httpd_sys_content_t:s0
[root@servera html]# ll -Z file*
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:08 file1
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:07 file2
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:07 file3
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:08 file4



添加文件上下文至数据库
[root@servera html]# mkdir /setest
[root@servera html]# ls -Zd /setest
unconfined_u:object_r:default_t:s0 /setest

[root@servera html]# semanage fcontext -l | grep /setest
[root@servera html]# semanage fcontext -a -t httpd_sys_content_t "/setest(/.*)?"  添加，并指定默认上下文
[root@servera html]# semanage fcontext -l | grep /setest
/setest(/.*)?                                      all files          system_u:object_r:httpd_sys_content_t:s0 
[root@servera html]# restorecon -Rv /setest/   更新/setest上下文与数据库一致
Relabeled /setest from unconfined_u:object_r:default_t:s0 to unconfined_u:object_r:httpd_sys_content_t:s0


$chcon
[root@servera html]# touch /tmp/file5;ls -Z /tmp/file5
unconfined_u:object_r:user_tmp_t:s0 /tmp/file5
[root@servera html]# chcon -t httpd_sys_content_t /tmp/file5
[root@servera html]# ll -Z file5
-rw-r--r--. 1 root root unconfined_u:object_r:httpd_sys_content_t:s0 0 Apr 10 05:15 file5

$chcon和restorecon 哪个更优先？
chcon 临时直接设定上下文
restorecon 恢复至数据库的默认状态


总结
修改上下方式两种
1、chcon  -t  文件、目录

2、semanage fcontext {-a|-m} -t 上下文类型       文件、目录 
   restorecon -Rv

练习：
将apache的默认发布目录修改为/custom,开启selinux
1、安装apache，并开启服务，访问测试
yum install -y httpd
systemctl enable --now httpd
curl localhost
2、修改发布目录，将/var/www/html/修改为/custom
[root@servera html]# mkdir /custom;echo test_web_page > /custom/index.html
[root@servera html]# cat /custom/index.html
test_web_page
[root@servera html]# vim /etc/httpd/conf/httpd.conf 
DocumentRoot "/var/www/html"    改为	DocumentRoot "/custom"
<Directory "/var/www/html">		改为	<Directory "/custom">
oot@servera html]# systemctl restart httpd
root@servera html]# setenforce 0		当关闭selinux时，可以访问
[root@servera html]# curl localhost/index.html     此处访问到了网页
test_web_page
[root@servera html]# setenforce 1		当开启selinux时，不可访问
[root@servera html]# curl localhost/index.html    
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>403 Forbidden</title>     #无权限
</head><body>
<h1>Forbidden</h1>
<p>You don't have permission to access /index.html
on this server.<br />
</p>
</body></html>
3、开启selinux时，将/custom的上下文修改为httpd_t进程可对应的上下文httpd_sys_content_t，才可访问
[root@servera html]# semanage fcontext -a -t httpd_sys_content_t "/custom(/.*)?"
[root@servera html]# restorecon -Rv /custom/
Relabeled /custom from unconfined_u:object_r:default_t:s0 to unconfined_u:object_r:httpd_sys_content_t:s0
Relabeled /custom/index.html from unconfined_u:object_r:default_t:s0 to unconfined_u:object_r:httpd_sys_content_t:s0
[root@servera html]# curl localhost/index.html
test_web_page
```

### 六、使用布尔值调整

```bash
布尔值主要对应的是应用的功能的开启或关闭
getsebool 		列出布尔值状态  user
setsebool -P	更改布尔值永久生效
semanage boolean -l 查看布尔值是否永久

selinux-policy-doc 
[root@servera /]# yum install -y selinux-policy-doc
[root@servera /]# mandb
[root@servera /]# man -k '_selinux' | grep httpd
[root@servera /]# man 8 httpd_selinux
[root@servera /]# getsebool -a

修改布尔值状态
[root@servera /]# setsebool httpd_enable_homedirs on
[root@servera /]# setsebool httpd_enable_homedirs off
[root@servera /]# semanage boolean -l  | grep httpd_enable_home
httpd_enable_homedirs          (off  ,  off)  Allow httpd to enable homedirs
[root@servera /]# setsebool -P httpd_enable_homedirs on  永久生效
[root@servera /]# semanage boolean -l  | grep httpd_enable_home
httpd_enable_homedirs          (on   ,   on)  Allow httpd to enable homedirs


用户可以通过web访问servera的studnet用户家目录中的网页
1、安装apache
2、开启apache访问普通用户家目录的功能 
[root@servera /]# vim /etc/httpd/conf.d/userdir.conf
#UserDir disabled
UserDir public_html
[root@servera /]# systemctl restart httpd   （重启服务生效配置文件，如果不能重启开启bool值相应功能后才可重启服务）
3、创建普通用户发布目录和权限
[root@servera ~]# su - student
[student@servera ~]$ pwd
/home/student
[student@servera ~]$ mkdir public_html;cd public_html/
[student@servera public_html]$ echo webserver_userdir > index.html 
[student@servera public_html]$ logout
[root@servera ~]# ll -d /home/student/
drwx------. 3 student student 102 Aug  2 09:24 /home/student/
[root@servera ~]# chmod 711 /home/student/

4、打开布尔值
[root@servera home]# setsebool -P httpd_enable_homedirs on
[root@servera student]# chcon -t httpd_user_content_t     /home/student/public_html/index.html    #添加selinux上下文标签

5、打开防火墙（如果是本地测试访问，不需要配置）
[root@servera home]# firewall-cmd --permanent --add-service=http
success
（注意如果当前apache的端口非80端口，需要使用防火墙允许默认端口
firewall-cmd --permanent --add-port=82/tcp）
[root@servera home]# firewall-cmd --reload
success
[root@servera home]# firewall-cmd --list-all
[root@servera html]# systemctl restart httpd
6、http：//172.25.250.10/~student/index.html

7、关闭bool值再测试
[root@servera html]# setsebool -P httpd_enable_homedirs off
[root@servera html]# curl localhost/~student/index.html
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>403 Forbidden</title>
</head><body>
<h1>Forbidden</h1>
<p>You don't have permission to access /~student/index.html
on this server.<br />
</p>
</body></html>

```

#### 七、selinux允许服务端口

```bash
练习：
希望用户可以通过8090 端口访问apache服务中的默认索引页
1、配置selinux允许8090端口
[root@servera html]# man semanage
[root@servera html]# man 8 semanage-port
[root@servera html]# semanage port -a -t http_port_t -p tcp 8090
[root@servera html]# semanage port -l | grep http_port_t
2、安装apache，修改配置文件，添加默认监听端口8090
[root@servera html]# vim /etc/httpd/conf/httpd.conf 
Listen 8090
[root@servera html]# systemctl restart httpd
3、允许防火墙
[root@servera html]# firewall-cmd --permanent --add-service=http
[root@servera html]# firewall-cmd --permanent --add-port=8090/tcp
[root@servera html]# firewall-cmd --reload
success
[root@servera html]# firewall-cmd --list-all
public (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp1s0
  sources: 
  services: cockpit dhcpv6-client http ssh
  ports: 8090/tcp
  
  4、浏览器访问
  http://172.25.250.10:8090
```



# 第六章 管理基本存储

MBR分区方案

mbr叫做主引导记录，IBM公司提出的，它存在于磁盘的0柱面0磁道0扇区中，是磁盘的第一个扇区内，大小为512字节 446字节初始化程序加载器 64字节分区表 2字节校验码，每个分区16字节，所以最多4个分区，最大磁盘空间支持2T

GPT分区方案

GPT是GUID Partition Table，全局唯一标识磁盘分区表。它由UEFI启动硬盘，这样就有了UEFI取代传动BIOS，而GPT则取代传统的MBR，windows支持最多128个GPT分区。

|    0     | mbr  |     dpt     |      |
| :------: | :--: | :---------: | :--: |
| 512 Byte | 446  |     64      |  2   |
|          |      | Primary<=4  |      |
|          |      |  Extend<=1  |      |
|          |      | Logical<=14 |      |

|  ID  |              | Count | Size |           |      |
| :--: | ------------ | ----- | ---- | --------- | ---- |
|  1   | mbr \| msdos | 15    | 2TB  | 3P+1E(nL) | 4P   |
|  2   | gpt          | 128   | 8ZB  | P         |      |

|  ID  |        |       Windows       |                            Linux                             |    MacOS     |
| :--: | ------ | :-----------------: | :----------------------------------------------------------: | :----------: |
|  1   | local  | ntfs, fat32,  exfat | xfs, ext4 \| swap [exfat](https://centos.pkgs.org/8/rpmfusion-free-updates-x86_64/) | apfs,  exfat |
|  2   | remote |      cifs, nfs      |                                                              |              |

### 一、fdisk

```bash
使用新磁盘：
分区-格式化-挂载-使用

fdisk -l 查看所有磁盘状态
fdisk  -l /dev/vdb  
#fdisk /dev/vdb
n
p
1
回车，不通过扇区范围分配
+1G  设置一个1G大小分区
p  查看分区状态

d 删除
w  保存退出

#partprobe    磁盘分区正常结束后，此命令可以正常执行
```

### 二、parted

```bash
切换mbr及gpt分区方案方法：
parted /dev/vdc mklabel msdos
parted /dev/vdc print
parted /dev/vdc mklabel gpt
parted /dev/vdc print



mbr方式
[root@servera /]# parted /dev/vdc 
(parted) mklabel                                                          
New disk label type? msdos                                                
Number  Start  End  Size  Type  File system  Flags
(parted) mkpart                                                           
Partition type?  primary/extended? p                                      
File system type?  [ext2]? ext4
Start? 2048s                                                              
End? 1000MB                                                               
(parted) p                                                                
Model: Virtio Block Device (virtblk)
Disk /dev/vdc: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size   Type     File system  Flags
 1      1049kB  1000MB  999MB  primary  ext4         lba

(parted) quit                                                             
Information: You may need to update /etc/fstab.
[root@servera ~]# udevadm  settle 
命令：
[root@servera /]# parted /dev/vdc mkpart p ext4 1000MB 2000MB



gpt方式：
[root@servera /]# parted /dev/vdd
(parted) mklabel gpt   
(parted) mkpart                                                           
Partition name?  []? part1
File system type?  [ext2]? xfs                                            
Start? 2048s                                                              
End? 1000MB                                                               
(parted) p                                                                
Model: Virtio Block Device (virtblk)
Disk /dev/vdd: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size   File system  Name   Flags
 1      1049kB  1000MB  999MB  xfs          part1

(parted) quit     
[root@servera ~]# udevadm  settle 
命令：
[root@servera /]# parted /dev/vdd mkpart part2 xfs 1000MB 2000MB



格式化：
[root@servera /]# mkfs -t ext4 /dev/vdc1 	
[root@servera /]# mkfs.xfs /dev/vdc2
[root@servera /]# lsblk --fs /dev/vdc
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
vdc                                                      
├─vdc1 ext4         af656cc6-80e3-4b05-abcf-a162907c2f0a 
└─vdc2 xfs          64237913-4937-48ff-8afa-28c6fc05124d 
[root@servera /]# parted /dev/vdc p
Model: Virtio Block Device (virtblk)
Disk /dev/vdc: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size   Type     File system  Flags
 1      1049kB  1000MB  999MB  primary  ext4
 2      1000MB  2000MB  999MB  primary  xfs
 
 
查看文件系统
lsblk  --fs /dev/vdc
blkid
```

### 三、挂载与永久挂载

mount   源设备  挂载点

mount  /dev/vdb1    /mnt/disk1

```bash
mount  临时
[root@servera /]# mkdir /mnt/dir1
[root@servera /]# mkdir /mnt/dir2
[root@servera /]# mount /dev/vdc1 /mnt/dir1
[root@servera /]# mount /dev/vdc2 /mnt/dir2
[root@servera /]# df -h
[root@servera /]# umount /mnt/dir2

使用UUID方式挂载
root@serverb ~]# blkid /dev/vdb2
/dev/vdb2: UUID="f131c11b-0aaf-4f1f-8b4c-39787333b203" TYPE="xfs" 
[root@serverb ~]# mount UUID="f131c11b-0aaf-4f1f-8b4c-39787333b203" /mnt/disk2


开机自动挂载   永久
 /etc/fstab
#vim /etc/fstab
/dev/vdc1 /mnt/dir1 ext4  defaults 0 0
UUID=64237913-4937-48ff-8afa-28c6fc05124d  /mnt/dir2 xfs defaults 0 0

设备ID或设备名称	 挂载点	文件系统类型   权限   内核日志检测机制0不检测  磁盘检测机制0不检测
#mount -a （挂载/etc/fstab中所有未挂载的设备）
#df  -h
#reboot

`注意`
如果/etc/fstab中配置错误导致不能启动系统，重启时会自动进入救援模式，此时输入管理员root密码，vi /etc/fstab更改正内容确后reboot即可
```

#### 四、管理交换分区

```bash
创建swap 
流程： 分区-格式化-挂载
[root@servera ~]# free -m  查看当前swap分区大小 或  top命令
[root@servera ~]# parted /dev/vdd mkpart backup xfs 2000MB 3000MB
[root@servera ~]# parted /dev/vdd p
Model: Virtio Block Device (virtblk)
Disk /dev/vdd: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system  Name    Flags
 1      1049kB  1000MB  999MB                part1
 2      1000MB  2000MB  999MB                part2
 3      2000MB  3000MB  1000MB               backup

[root@servera ~]# mkswap /dev/vdd3
[root@servera ~]# swapon /dev/vdd3
[root@servera ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1829         173        1464          24         190        1488
Swap:           953           0         953
[root@servera ~]# swapoff /dev/vdd3
[root@servera ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1829         172        1465          24         190        1488
Swap:             0           0           0

开机自动加载swap
[root@servera ~]# vim /etc/fstab 
/dev/vdd3 swap swap defaults 0 0
[root@servera ~]# swapon -a
[root@servera ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1829         173        1464          24         190        1488
Swap:           953           0         953

#reboot重启验证



例题：
添加一个1G交换分区，并且重启系统依然有效。不能更改原来的swap分区（系统默认已经有了500M）
free -m
swap  500

创建swap
格式化swap
vim /etc/fstab

结果：
free -m  
1500


了解：
swap-file
# df -h
# dd if=/dev/zero of=/pagefile.sys bs=512M count=1
# mkswap /pagefile.sys 
# chmod 0600 /pagefile.sys 
# vim /etc/fstab 
...
/pagefile.sys swap swap defaults 0 0 
# swapon -a
# free -h
```



# 第七章 逻辑卷管理

PV

VG

PE

LV

逻辑卷管理

```bash
创建逻辑卷
分区或者添加物理硬盘---pv让物理磁盘或分区变成lvm可用的卷--创建vg同时指定pe块大小----在vg中划分lv空间---格式化lv空间--格式化－-挂载或者永久挂载。

Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x0be8a7fd

Device     Boot   Start      End Sectors Size Id Type
/dev/vdb1          2048  2099199 2097152   1G 83 Linux
/dev/vdb2       4196352 10485759 6289408   3G  5 Extended
/dev/vdb3       2099200  4196351 2097152   1G 83 Linux
/dev/vdb5       4198400  6295551 2097152   1G 83 Linux

# pvcreate /dev/vdb{1,3,5}
# pvscan   或者  pvdisplay

# vgcreate -s 16M myvg /dev/vdb1 /dev/vdb3    
# vgdisplay 

# lvcreate -L 1G -n mylv myvg　　　　（－L　指定具体大小-L 1G 　，　－ｌ　指定ｐｅ块数量  -l 32）
# lvdisplay 

# mkfs.xfs /dev/myvg/mylv 
# lsblk --fs /dev/myvg/mylv

# mkdir /mnt/lvm
# mount /dev/myvg/mylv /mnt/lvm
# df -h
# cd /mnt/lvm/

永久挂载
vim /etc/fstab
/dev/myvg/mylv  /mnt/lvm  xfs defaults 0 0 
[root@servera /]# mount -a

reboot重启验证

删除逻辑卷思路：
创建顺序---分区--lv（pv-vg-lv）--格式化---挂载
卸载顺序---卸载--删lv--删vg--删pv--删分区
vgremove vg00

```

### 扩展逻辑卷

```bash
扩展流程：
lvextend 【-L| -l】【size|PE】
1、扩展lv大小 -L +100M 容量   , -l +40  PE数量
2、将其生效：ext 文件系统 ”resize2fs 设备名“ ，xfs 文件系统   “xfs_growfs 挂载点”

需求，目前vg=2G，lv=1G，想把lv扩展到2.5G
添加PV 
已经添加了/dev/vdb5,如果没添加可以使用：[root@servera /]# pvcreate /dev/vdb5
扩展vg
先创建pv /dev/vdb5
[root@servera /]# man vgextend 
[root@servera /]# vgextend myvg /dev/vdb5
  Volume group "myvg" successfully extended
[root@servera /]# vgdisplay 

扩展lv
[root@servera /]# lvextend -L +1500M /dev/myvg/mylv 或者lvextend -L 2500M /dev/myvg/mylv
[root@servera /]# df -h

如果是xfs文件系统使用：
[root@servera /]# xfs_growfs /mnt/lvm (挂载点)
[root@servera /]# df -h

如果是ext4文件系统使用：
[root@servera /]# resize2fs /dev/myvg/mylv （lv设备名）


`注意`
lvextend -l 30 -n mylv myvg  将lv设置为30个pe块
lvextend -l +30 -n mylv myvg 将lv继续添加30个pe块


练习
系统有一个lv，名称为mylv，属于myvg，当前大小480M，需要扩展到600M，
最终lv大小范围需要在580M至620M之间，文件系统xfs\
lvextend -L 600M /dev/myvg/mylv
xfs_growfs /mnt/xxx



$缩小lv:ext文件系统可以缩小，xfs不支持
1、卸载
2、resize2fs 定义缩小后的大小
3、磁盘检测
4、lvresize -L 1G 逻辑卷名

# umount /dev/myvg/mylv
# resize2fs /dev/myvg/mylv 1G
# e2fsck -f /dev/myvg/mylv
# resize2fs /dev/myvg/mylv 1G
# lvdisplay 
# lvresize -L 1G /dev/myvg/mylv 
# lvdisplay

创建的lv名称为myly，属于myvg卷组，lv需要30个pe，每个pe16M，需要开机自动挂载到/mnt/mylvdir. 并且使用xfs文件系统
```

# 第八章 实施高级存储功能

### stratis 本地存储管理系统多个存储层

### 使用VDO压缩存储设备上的数据并进行重复删除、以优化存储空间使用 



stratis

```bash
# yum install -y stratis-cli stratisd
# systemctl enable --now stratisd

[root@servera ~]# fdisk -l /dev/vdb
Disk /dev/vdb: 5 GiB, 5368709120 bytes, 10485760 sectors
Device     Boot   Start     End Sectors Size Id Type
/dev/vdb1          2048 2099199 2097152   1G 83 Linux
/dev/vdb2       2099200 4196351 2097152   1G 83 Linux

[root@servera ~]# stratis pool create pool1 /dev/vdb1
[root@servera ~]# stratis pool list
[root@servera ~]# stratis blockdev list
[root@servera ~]# stratis pool add-data pool1 /dev/vdb2
[root@servera ~]# stratis pool list
Name     Total Physical Size  Total Physical Used
pool1                  2 GiB               56 MiB
[root@servera ~]# stratis blockdev list
Pool Name  Device Node    Physical Size   State  Tier
pool1      /dev/vdb1              1 GiB  In-use  Data
pool1      /dev/vdb2              1 GiB  In-use  Data

创建文件系统
[root@servera ~]# stratis filesystem create pool1 filesystem1
[root@servera ~]# 
[root@servera ~]# stratis filesystem list 
Pool Name  Name         Used     Created            Device                      UUID                         
pool1      filesystem1  546 MiB  Mar 16 2020 21:47  /stratis/pool1/filesystem1  6d1ed6e714a6428eb374549b4fdd8d2b  
[root@servera ~]# mkdir /mnt/stratisvol
[root@servera ~]# mount /stratis/pool1/filesystem1 /mnt/stratisvol/



备份：
创建测试文件

[root@servera /]# cd /mnt/stratisvol/
[root@servera stratisvol]# dd if=/dev/zero of=myfile bs=1M count=100
[root@servera stratisvol]# du -sh myfile 
备份
[root@servera /]# stratis filesystem snapshot pool1 filesystem1 filesystembak1
模拟故障
[root@servera /]# cd /mnt/stratisvol/
[root@servera stratisvol]# ls
file1  myfile
[root@servera stratisvol]# rm -f *
[root@servera stratisvol]# cd /
[root@servera /]# umount /mnt/stratisvol
恢复
[root@servera /]# mkdir /mnt/stratisvolbak
[root@servera /]# mount /stratis/pool1/filesystembak1 /mnt/stratisvolbak/



开机自动启动：
vim /etc/fstab
/stratis/pool1/filesystembak1 /mnt/stratisvolbak/ xfs _netdev 0 0
mount -a
```

VDO

```bash
yum install -y vdo kmod-kvdo
systemctl enable --now vdo 

man vdo
vdo create --name=vdo0 --device=/dev/vdb --vdoLogicalSize=50G
vdo start  --name=vdo0
vdo stop  --name=vdo0
vdo status --name=vdo0
mkfs.xfs -K /dev/mapper/vdo0 
vdo list

mkdir /mnt/vdo0
mount /dev/mapper/vdo0 /mnt/vdo0/
df -h

man vdostats
[root@servera vdo0]# vdostats --human-readable 
Device                    Size      Used Available Use% Space saving%
/dev/mapper/vdo0          5.0G      3.0G      2.0G  60%           99%



cd /mnt/vdo0/
ls
dd if=/dev/zero of=./bigfile bs=400M count=1

du -sh /mnt/vdo0/bigfile
vdostats --human-readable
blkid


开机自动挂载
du -sh
umount /mnt/vdo0
systemctl status vdo.service 
vim /etc/fstab 
/dev/mapper/vdo0 /mnt/vdo0 xfs _netdev 0 0


mount -a

man mount
 _netdev
             文件系统驻留在需要网络的设备上
访问(用于防止系统试图挂载
这些文件系统，直到网络已经启用
系统)。
```

# 第九章 访问网络存储

NFS 网络文件系统

- mount

- vim /etc/fstab

- autofs

  ```bash
  【foundation】
  root@foundation0 ~]# systemctl status nfs-server.service 
  [root@foundation0 ~]# vim /etc/exports
  /content    172.25.0.0/255.255.0.0(ro,sync,crossmnt)
  共享目录	  允许访问的网段           权限
  [root@foundation0 ~]# showmount -e localhost
  Export list for foundation0.ilt.example.com:
  /content 172.25.0.0/255.255.0.0
  
  【servera】
  [root@servera ~]# ping 172.25.254.250
  [root@servera ~]# showmount -e 172.25.254.250
  Export list for 172.25.254.250:
  /content 172.25.0.0/255.255.0.0
  [root@servera ~]# mkdir /mnt/nfs/
  [root@servera ~]# mount 172.25.254.250:/content /mnt/nfs/
  
  开机自动挂载
  [root@servera ~]# umount /mnt/nfs
  [root@servera ~]# vim /etc/fstab
  172.25.254.250:/content/ /mnt/nfs/  nfs defaults 0 0
  [root@servera ~]# mount -a
  [root@servera ~]# df -h
  [root@servera ~]# reboot  （重启后使用df -h查看挂载状态）
  
  【servera】
  autofs
  yum install -y autofs
  systemctl status autofs
  systemctl enable --now autofs
  systemctl status autofs
  systemctl is-enabled autofs
  
  [root@servera ~]# rpm -qa | grep autofs
  libsss_autofs-2.0.0-43.el8.x86_64
  autofs-5.1.4-29.el8.x86_64
  [root@servera ~]# 
  [root@servera ~]# rpm -qc autofs 
  /etc/auto.master
  /etc/auto.misc
  
  mount -t nfs -o rw  172.25.254.250:/content  /mnt/nfs1
  
  172.25.254.250:/content     /mnt/nfs1    nfs    defaults  0 0 
  
  
  [root@servera ~]# vim /etc/auto.master
  /mnt/    /etc/auto.misc
  [root@servera ~]# vim /etc/auto.misc
  dir1            -fstype=nfs,rw     172.25.254.250:/content
  
  [root@servera ~]# systemctl restart autofs
  [root@servera ~]# cd /mnt/dir1
  [root@servera dir1]# df -h
  172.25.254.250:/content  491G   40G  451G   9% /mnt/dir  不和/etc/fstab一起用
  
  ```






# 第十章 启动流程

```
  vim /etc/systemd/system/default.target
  systemctl cat default.target 
  systemctl list-dependencies 
  systemctl list-dependencies | grep target
  systemctl list-dependencies graphical.target
  
  systemctl get-default 
  syetemctl set-default  multi-user.target
  
  
  
  
  
  切换图形或字符
  [root@workstation ~]# systemctl isolate multi-user.target 
  [root@workstation ~]# systemctl isolate graphical.target
  
  注意：如果安装了图形，启动后需要执行startx
  
  
  启动时选择其他目标
  reboot
  e
  linux.....<end> systemd.unit=graphical.target    或multi-user.target
  ctrl+x
  
 
  
  修改登录密码
  reboot
  e
  linux.....<end> rd.break console=tty0
  ctrl+x
　mount -o remount,rw /sysroot/
  chroot /sysroot
　echo mima | passwd --stdin root
  touch /.autorelabel
  exit
  exit
  
  
  
  
```

  # 

#   第十一章 firewalld

  ```bash
   systemctl status firewalld
   systemctl enable --now firewalld
   
  firewall-cmd --get-default-zone 
  firewall-cmd --list-all
  man 5 firewalld.zones
  firewall-cmd --get-zones
  
  
  man firewall-cmd
  /Ex
  firewall-cmd -- 
  firewall-cmd --get-zones
  firewall-cmd --get-default-zone 
  firewall-cmd --set-default-zone=public
  firewall-cmd --get-default-zone 
  firewall-cmd --list-all
  
  firewall-cmd --get-service
  
  
  firewall-cmd --add-source=172.25.250.100 --zone=trusted --permanent
  firewall-cmd --reload
  
  firewall-cmd --add-interface=enp2s0 --zone=trusted --permanent
  firewall-cmd --reload
  
  ```

  允许服务及端口

  ```bash
  【servera】
  yum install -y httpd
  rpm -qc httpd
  setenforce 0
  rpm -ql httpd
  cd /var/www/html/
  echo "webservera" > index.html
  systemctl enable --now httpd
  
  firewall-cmd --permanent --add-service=http
  firewall-cmd --reload
  firewall-cmd --list-all
  【serverb： curl http://servera】
  
  vim /etc/services 
  netstat -ntlp | grep 80
  lsof -i:80
  
  firewall-cmd --info-service=http
  vim /etc/httpd/conf/httpd.conf 
  Listen 80 改成了Listen 82
  
  systemctl restart httpd
  setenforce 0
  netstat -ntlp | grep 82
  lsof -i:82
  firewall-cmd --permanent --add-port=82/tcp
  firewall-cmd --reload
  firewall-cmd --list-all
  【serverb： curl http://servera:82】
  
  lsof -i：80	
  ```

  2 、通过管理selinux标签来控网络服务，允许特定端口

  ```bash
  [servera]
  setenforce 1
  systemctl status httpd
  vim /etc/httpd/conf/httpd.conf 
  Listen 80 改成了Listen 8899
  systemctl restart httpd   重启不了，因为selinux
  semanage port -l | grep http
  man semanage port
  /example
  semanage port -a -t http_port_t -p tcp 8899
  semanage port -l | grep http
  
  systemctl restart httpd
  systemctl enable httpd
  systemctl enable --now httpd
  
  firewall-cmd --permanent --add-port=8899/tcp
  firewall-cmd --reload
  firewall-cmd --list-all
  
 
  
  【test case】
  [serverb curl http://servea:8899] 
  
 
  
  
  富规则参考
  man 5 firewalld.richlanguage
  ```

  test

  ```
  vsftp
  samba
  nfs
  dhcp
  ```

  

# 第 十二 章 kickstart

在workstation上面做服务器端，servera做客户端，务必使用rh124环境

cd 

iso

网络安装



```bash
systemctl stop firewalld;setenforce 0
【servera】 server
一、dhcp
yum search dhcp
yum install -y dhcp-server
rpm -ql dhcp-server
vim /etc/dhcp/dhcpd.conf 
cp /usr/share/doc/dhcp-server/dhcpd.conf.example /etc/dhcp/dhcpd.conf
man 5 dhcpd.conf
/next-server
vim /etc/dhcp/dhcpd.conf
allow bootp;
allow booting;
subnet 172.25.250.0 netmask 255.255.255.0 {
  range 172.25.250.100 172.25.250.200;
  option routers 172.25.250.254;
  default-lease-time 600;
  max-lease-time 7200;
  filename "/pxelinux.0";
  next-server 172.25.250.10;
}

systemctl enable --now dhcpd
测试dhcp功能
设置serverb开机启动为网卡启动，当做客户端，测试能够获取ip即可

二、tftp and syslinux
yum search tftp
yum install -y tftp-server tftp
rpm -ql tftp-server


yum install -y syslinux-tftpboot.noarch
rpm -ql syslinux-tftpboot
cd tftpboot/
mkdir /tftpboot/pxelinux.cfg/

mkdir /content
mount 172.25.254.250:/content /content/
df -h
cd /content/rhel8.0/x86_64/dvd/

cp isolinux/isolinux.cfg /tftpboot/pxelinux.cfg/default

cp isolinux/{boot.msg,vesamenu.c32} /tftpboot/
cp images/pxeboot/{initrd.img,vmlinuz} /tftpboot/
vim /tftpboot/pxelinux.cfg/default 
default `vesamenu.c32` (反引号告诉大家是需要关注的点,实际配置不需要反引号)
timeout 600
display `boot.msg`

label linux
  menu label ^Install Red Hat Enterprise Linux 8.0.0
  menu `default`
  kernel `vmlinuz`
  append initrd=`initrd.img` inst.stage2=`ftp://172.25.250.9/dvd` quiet

vim /usr/lib/systemd/system/tftp.service 
[Service]
ExecStart=/usr/sbin/in.tftpd -s /tftpboot  (将-s /var/lib/tftpboot，更成-s /tftpboot)

systemctl enable --now tftp
测试：
登录servera，yum install -y tftp ,tftp 172.25.250.10,get ls.c32 quit


三、ftp
yum install -y vsftpd.x86_64 
rpm -qc vsftpd
vim /etc/vsftpd/vsftpd.conf 
anonymous_enable=YES
anon_root=/var/ftp
mkdir /var/ftp/dvd
mount /content/rhel8.0/x86_64/isos/rhel-8.0-x86_64-dvd.iso /var/ftp/dvd/

df -h
systemctl enable --now vsftpd


【servera】cleint
以网卡方式启动--安装1、指定ftp路径172.25.250.9/dvd 2 最小化 3 设置lvm分区
进度条走完-重启，添加硬盘启动 ， 从本地硬盘启动。



```

```bash
# cp anaconda-ks.cfg ks.cfg
# vim ks.cfg
#version=RHEL8
ignoredisk --only-use=vda
bootloader --append="console=ttyS0 console=ttyS0,115200n8 no_timer_check net.ifnames=0  crashkernel=auto" --location=mbr --timeout=1 --boot-drive=vda
zerombr
clearpart --all --initlabel
reboot
text
url --url="ftp://172.25.250.9/dvd"
keyboard --vckeymap=us --xlayouts=''
lang en_US.UTF-8
network  --bootproto=dhcp --device=link --activate
rootpw --iscrypted nope
auth --enableshadow --passalgo=sha512
selinux --enforcing
firstboot --disable
services --disabled="kdump,rhsmcertd" --enabled="sshd,NetworkManager,chronyd"
timezone America/New_York --isUtc
part / --fstype="xfs" --ondisk=vda --size=8000

%post --erroronfail
echo redhat | passwd --stdin root
useradd tom
%end

%packages
@core
@base
NetworkManager
dnf-utils
-plymouth
%end
# cp ks.cfg /var/ftp/
# chmod o+r /var/ftp/ks.cfg
# ll /var/ftp/ks.cfg 
```

# [13. Running Containers](http://foundation0.ilt.example.com/slides/RH134-RHEL8.2-en-1-20200928/#/105)

![podman](https://gitee.com/suzhen99/redhat/raw/master/images/podman.svg)

**总目标：在一个 RHEL 服务器上获取、运行和管理作为容器的简单轻量级服务**

**目标：**

- 解释容器是什么，及如何管理和部署具有软件库和依赖的应用程序
- 安装容器管理工具，并运行一个简单的无根容器
- 查找、检索、检查和管理容器映像，从远程容器仓库获得并存储在服务器中
- 使用选项来运行容器，列出在系统上运行的容器，启动、停止和强制关闭容器
- 通过在运行的容器中挂载目录，以使用容器永久存储
- 以 systemd 服务的方式启动、停止和检查容器



**章节：**

1. [容器介绍](#13.1)

2. [运行一个基本的容器](#13.2)

3. [查找并管理容器映像](#13.3)

4. [实施高级的容器管理](13.4)

5. [为容器附加永久存储](13.5)

6. [以服务方式管理容器](13.6)

7. [实验](#13.l)

8. [总结](#13.s)

   

#### <a name="13.1">第一节：容器介绍</a>

**目标：**

- 解释容器是什么，及如何管理和部署具有软件库和依赖的应用程序

**1.1 容器技术介绍：**

- 应用程序通常依赖于 runtime environment 提供的库、配置文件或服务。`传统上，应用程序的 runtime environment 安装在运行在物理主机或虚拟机上的操作系统中。应用程序依赖项与该操作系统一起安装在主机上`
- 在 RHEL 中，使用 RPM 帮助管理应用程序依赖关系。当安装httpd 包时，RPM 系统会确保安装了正确的库和依赖项
- 应用程序可能需要比操作系统安装的更老或更新的软件版本。或在同一系统上的两个应用程序可能需要同一软件的不同版本，而版本彼此不兼容

- 解决这些冲突的一种方法是将应用程序打包并部署为容器

- 容器是与系统的其他部分隔离的一个或多个进程的集合。容器的内容与其他容器的内容是隔离的，不会相互影响

- 容器是打包应用程序以简化部署和管理的一种方法

**1.2 容器和虚拟化的对比：**

- 容器提供了许多与虚拟机相同的优点，例如安全性、存储和网络隔离

- 这两种技术都将它们的应用程序库和 runtime 资源与主机操作系统或管理程序隔离开来
  ![VirtualMachines-Containers](https://gitee.com/suzhen99/redhat/raw/master/images/VirtualMachines-Containers.png)

  <br>![Virtualization-Containers](https://gitee.com/suzhen99/redhat/raw/master/images/Virtualization-Containers.png)

- 容器和虚拟机与`硬件和底层操作系统交互方式`不同

- **虚拟化：**

  - 可以在单一硬件平台运行多操作系统
  - 使用 hypervisor 将硬件拆分成多个虚拟硬件，允许多个操作系统并行运行
  - 需要完整的操作系统来支持应用运行

- **容器：**

  - 在操作系统上`直接运行，容器之间分享硬件和操作系统资源`，容器中应用`轻量化和快速`并行运行
  - `共享`操作系统`内核`，将容器化的应用程序进程与系统的其余部分`隔离`，并使用与该内核兼容的任何软件
  - 比虚拟化要求`更少的硬件资源`，可以`快速启动和停止`，减少存储需求

**1.3 探索容器的实现：**

- RHEL 实现容器使用核心技术：
  - 用于资源管理的 Control Groups (cgroups)
  - 用于进程隔离的 Namespaces
  - SELinux 和 Seccomp（Secure Computing mode）加强安全边界

**1.4 计划使用容器：**

- 容器可移植性好。可以容易的从一个环境转移到另一个环境，比如从开发环境转移到生产环境

- 可以保存容器的多个版本，根据需要快速访问每个版本
- 容器通常是`临时（ephemeral）`的。可将运行中的容器生成的数据永久保存在`持久存储（persistent storage）`中
- 容器通常在需要时运行，不需要时停止并删除。下一次需要时，将启动一个新的容器进程
  ![container-storage](https://gitee.com/suzhen99/redhat/raw/master/images/container-storage.png)

**1.5 从容器映像（Container Image）运行容器：**

- 容器从容器映像（container image）运行。容器映像是创建容器的蓝图

- 容器映像打包一个应用程序连同它所有的依赖：
  - 系统库函数
  - 编程语言运行时
  - 编程语言库函数
  - 配置
  - 静态数据文件

- image `不可更改`

- image 根据`规范（OCI）`构建，例如 Open Container Initiative(OCI) image 格式规范。这些规范定义了 image 的格式及元数据

**1.6 设计基于容器的结构：**

- 可在单个容器中安装由多个服务组成的复杂软件应用程序。例如，可能有一个需要使用数据库和消息队列的 web 服务器。但是将一个容器用于多个服务是很难管理的

- 更好的设计是在`单独的容器`中运行每个组件、web服务器、数据库和消息队列。对单个应用程序组件的更新和维护不会影响其他组件或应用程序堆栈

**1.7 用 Podman 管理容器：**

![Podman](https://gitee.com/suzhen99/redhat/raw/master/images/2074831-20201129203558088-125133373.png)

> 1、Podman 直接与镜像注册表、容器和镜像存储进行交互
>
> 2、Podman 中没有使用守护进程，而是直接使用 runC 容器运行时
>
> 3、适用于 Docker 的命令在 Podman 中也是同样可用的
>
> 4、Podman 和 Docker 的镜像具有兼容性

- RHEL 提供了一套容器工具，可以实现：
  - podman：它直接管理容器和容器 image
  - skopeo：可以使用它检查、复制、删除和签名 image
  - buildah：可以使用它创建新的容器 image

- 这些工具与开放容器倡议（OCI）是`兼容`的。它们可以用于管理任何由`兼容 oci `的容器引擎（如Docker）创建的 Linux 容器

- 这些工具专门为在 RHEL 下的`单节点容器主机`上运行容器而设计

- 在本章中，将学习 `podman 和 skopeo 命令`来运行和管理容器和image

- 注：buildah 内容可以参考 [Introduction to Containers, Kubernetes, and OpenShift (DO180)](https://www.redhat.com/zh/services/training/do180-introduction-containers-kubernetes-red-hat-openshift)

**1.8 运行无根的容器：**

- 在容器主机上，用户能以根用户或普通用户运行容器。`非特权用户运行的容器称为无根容器`

- 无根容器`更安全`，但有一些限制。例如，无根容器不能通过容器主机的特权端口（1024以下的端口）发布网络服务

- 可以直接作为根用户运行容器，但这在一定程度上削弱了系统的安全性

**1.9 管理大量容器：**

- 越来越多的新应用程序使用容器实现，并彼此依赖。管理越来越多的容器很快就会成为一项难以应付的任务

- 在生产中大规模部署容器需要适应以下挑战：
  - 平台必须为客户提供容器的`可用性`
  - 环境必须能增加或减少运行的容器，并负载平衡流量来响应应用程序负载变化
  - 平台应该检测到容器或主机的故障并做出相应的反应
  - 开发人员需要一个自动化的工作流程，以透明和安全地向客户交付新的应用程序版本
- `Kubernetes` 是一种编排服务，可以更容易地跨容器主机部署、管理和伸缩基于容器的应用程序。它在启动新容器时管理 DNS 更新。它使用负载均衡将流量重定向到容器，还允许管理员手动或自动地伸缩提供服务的容器数量。它还支持用户定义的运行状况检查，以监视容器，并在容器失败时重新启动它们

- Red Hat 提供名为 `Red Hat OpenShift` 的 Kubernetes 发行版。OpenShift 是一组构建在 Kubernetes 基础设施之上的模块化组件和服务。它添加了一些额外的特性，例如基于 web 的远程管理、多租户、监视和审计、应用程序生命周期管理以及为开发人员提供的自助服务实例等等

- 注：Red Hat OpenShift 超出了本课程的范围，可以在 https://www.openshift.com了解更多有关它的信息

#### <a name="13.2">第二节：运行一个基本的容器</a>

**目标：**

- 安装容器管理工具，并运行一个简单的无根容器

**2.1 安装容器管理工具：**

|  ID  |    HOST     |         COMMENT          |
| :--: | :---------: | :----------------------: |
|  1   |  classroom  |         yum repo         |
|  2   |   bastion   |          router          |
|  3   |   utility   |  container-server: Quay  |
|  4   | **servera** | container-client: podman |

**[kiosk@foundation]**

```bash
$ rht-clearcourse 0
$ rht-setcourse rh134
  
$ for i in classroom bastion utility servera; do
    rht-vmctl start $i
  done
```

- 要在系统上运行和管理容器，使用 yum 安装 `container-tools` 模块（module）

  **[student@servera]**

  ```bash
  $ yum module list container*
  ```

  ```bash
  $ sudo yum module -y install container-tools
  ```

- 容器工具模块包括安装多个工具的软件包。本章使用是 `podman 和 skopeo`

**2.2 选择容器 image 和 registry：**

- 容器 registry 是用于存储和检索容器 image 的存储库。开发人员将 image 上传或推送到 registry。用户可以从 registry 下载或拉取这些容器 image 到本地系统，以便运行容器
- 可以使用包含第三方 image 的 `public registry`，也可以使自建的 `private registry`。容器 image 的来源很重要，是否可以信任 images 中的代码。不同的 registry 对于是否以及如何提供、评估和测试提交给它们的 images 有不同的策略
- https://catalog.redhat.com/software/containers/explore
  - Red Hat 通过两个主要的 registry 分发经过认证的 images ，用户可以使用 Red Hat 账户访问这些 registry：
    - [registry.redhat.io](https://registry.redhat.io) 基于红帽官方产品的 images
    - [registry.connect.redhat.com](https://registry.connect.redhat.com) 用于基于第三方产品的 images
  - 红帽正在逐步淘汰一个较老的registry：[registry.access.redhat.com](https://registry.access.redhat.com)
- 红帽容器目录（https://access.redhat.com/containers）提供了一个基于 web 的界面，可以索这些 registry 以获得认证的 images
- **注：**本课程运行一个基于 [Red Hat Quay](https://www.redhat.com/zh/technologies/cloud-computing/quay) 的私有 registry，以提供容器 images  

**2.3 容器 image 的命名格式：**

- **registry_name/user_name/image_name:tag**
  - registry_name：是存储 image 的 registry 名称，一般是 registry 的域名
  - user_name：是 image 所属的用户或组织
  - image_name：必须在用户 userspace 中唯一
  - tag：用于区分 image 版本，如果 image 名称中不含有 tag，将默认使用 latest tag

**2.4 运行容器：**

- 要在本地系统上运行容器，必须首先`下载（pull）`容器 image。使用 Podman 从 registry 中下载 images

- 在 pull images 时，应始终使用完整的 image 名称。`podman pull` 命令从 registry 中提取指定的 image 并保存到本地：

  **[kiosk@foundation]**

  >  firefox https://registry.lab.example.com

  **[student@servera]**

  ```bash
  $ podman login --help
  $ podman login -u admin -p redhat321 \
  --tls-verify=false registry.lab.example.com
  
  $ podman search \
  --tls-verify=false registry.lab.example.com/
  参数说明：（man podman search）
  NAME: 镜像仓库源的名称
  DESCRIPTION: 镜像的描述
  OFFICIAL: 是否 docker 官方发布
  stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。
  AUTOMATED: 自动构建。（Dockerfile是构建Docker应用镜像的脚本代码）
  ```

  ```bash
  $ podman pull \
  --tls-verify=false registry.lab.example.com/ubi8/ubi
  ```

  ```bash
  $ podman pull \
  --tls-verify=false registry.lab.example.com/ubi7/ubi
  ```

- 下载后，Podman 在本地存储 image，可以使用 `podman images` 命令列出：

  ```bash
  $ podman images
  REPOSITORY                          TAG      IMAGE ID       CREATED        SIZE
  registry.lab.example.com/ubi7/ubi   latest   87dd8ec61bbc   5 months ago   215 MB
  （ImageID:唯一标志一个镜像，其数值根据该镜像的元数据配置文件采用sha256算法的计算获得。）
  ```

  - 显示 image tag 是 `latest`，image id 是 `87dd8ec61bbc`

- 要从这个 image 运行一个容器，使用 `podman run` 命令，将从容器 image 创建并启动一个新的容器。如果需要，使用 `-it` 选项与容器交互。it 选项将终端分配给容器，并允许向其发送键盘指令

  ```bash
  $ podman run -it \
  registry.lab.example.com/ubi8/ubi:latest
  [root@99901bb00fc1 /]# <Ctrl-D>
  ```

  ```bash
  $ podman ps --all
  $ podman ps
  ```

- 如果运行一个容器使用完整 image name，但 image 还没有本地存储，则 podman run命令将先从 registry 中下载 image，再运行

- 注：-t = -tty ；-i = --interactive ；-d = --detach（background running）

- 当访问一个容器时，Podman 可使用容器 name 或生成的 ID。当使用 podman run 运行容器时，使用 `--name` 选项设置容器名，`容器名称必须是唯一的`。如果 podman run 命令不包含容器名称，那么podman将生成一个`随机名称`

  ```bash
  $ podman run -it --name=rhel8 registry.lab.example.com/ubi8/ubi
  [root@acd94b972f65 /]# exit
  ```

  ```bash
  $ podman ps --all
  $ podman ps
  ```

- `podman run --rm` 可以在不与容器交互的情况下在容器中运行快速命令，然后在命令完成后删除容器

  ```bash
  $ podman run --rm registry.lab.example.com/ubi8/ubi \
  cat /etc/os-release
  ```

  ```bash
  $ podman ps --all
  $ podman ps
  ```

**2.5 分析容器的隔离：**

- 容器提供了资源的 runtime 隔离。容器利用 Linux namespace 为资源（如进程、网络通信和卷）提供独立的、隔离的环境

- 在容器中运行的进程与主机上的所有其他进程是隔离的

- 查看容器内运行的进程：

  ```bash
  $ podman run -it registry.lab.example.com/ubi7/ubi /bin/bash
  [root@10855645141e /]# ps aux
  USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
  root           1  2.4  0.1  11840  2764 pts/0    Ss   20:30   0:00 /bin/bash
  root          14  0.0  0.1  51768  3212 pts/0    R+   20:31   0:00 ps aux
  ```

- 注意，容器内的用户名和 ID 与主机上的用户名和 ID 不同：

  ```bash
  [root@10855645141e /]# id
  uid=0(root) gid=0(root) groups=0(root)
  [root@10855645141e /]# exit
  $ id
  uid=1000(student) gid=1000(student) groups=1000(student),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
  ```

#### <a name="13.3">第三节：查找并管理容器映像</a>

**目标：**

- 查找、检索、检查和管理容器映像，从远程容器仓库下载并存储在服务器中

**3.1 配置容器 registries：**

- podman 在主机上使用 registry.conf 来配置容器 registry 信息

  ```bash
  $ grep -A 1 ^\\[regis.*search /etc/containers/registries.conf
  [registries.search]
  registries = ['registry.access.redhat.com', 'registry.redhat.io', 'docker.io']
  ```

- podman 可以访问的 registry 列表在 `[registry.search] `中配置。如果没有在命令行中指定 image 完整域名，那么 podman 将按照顺序搜索此段内容，帮助补全域名路径

  - 方法一

  ```bash
  $ sudo vim /etc/containers/registries.conf
  ```

  ```toml
  # The initial configuration format
  #[registries.search]
  #registries = ['registry.lab.example.com']
  #[registries.insecure]
  #registries = ['registry.lab.example.com']
  #[registries.block]
  #registries = []
  ...
  :%s/^re/#re/g
  :%s/^\[re/#re/g
  
  # The second version of the configuration format
  unqualified-search-registries = ["registry.lab.example.com"]
  [[registry]]
  insecure = true
  blocked = false
  location = "registry.lab.example.com"
  ...
  ```

  - 方法二

  ```bash
  # wget -P /etc/yum.repos.d/ http://materials/updates.repo
  # yum update -y
  # mkdir -p .config/containers
  # wget http://materials/registries.conf -P .config/containers
  ```

  

- `podman info` 命令显示 Podman 的配置信息：

  ```bash
  $ podman info | grep -A 5 ^registries
  registries:
    blocked: null
    insecure:
    - registry.lab.example.com
    search:
    - registry.lab.example.com
  ```

**3.2 registry 安全：**

- 不安全的 registry 列在 registries.conf 的 [registry.inscure]中。到该 registry 的连接不受 TLS 加密保护

- 如果一个 registry 既可搜索又不安全，那么它可以在[registries.search] 和 [registries.insecure] 中同时写入

- registries 也可以配置为需要身份验证。使用 `podman login` 登录

  ```bash
  $ podman logout registry.lab.example.com
  ```

**3.3 搜索容器 image：**

- `podman search` 命令搜索特定容器 image 的 registry：

  ```bash
  $ podman search ubi
  ```

  ```bash
  $ podman search registry.lab.example.com/
  ERRO[0000] error searching registry "registry.lab.example.com": couldn\'t search registry "registry.lab.example.com": unable to retrieve auth token: invalid username/password: unauthorized: access to the requested resource is not authorized
  
  $ podman login -u admin -p redhat321 registry.lab.example.com
  Login Succeeded!
  ```

  ```bash
  $ podman search registry.lab.example.com/
  INDEX         NAME              DESCRIPTION   STARS   OFFICIAL   AUTOMATED
  example.com   registry.lab.example.com/rhel8/mariadb-103                 0
  example.com   registry.lab.example.com/rhel8/httpd-24                    0   
  example.com   registry.lab.example.com/library/nginx                     0
  example.com   registry.lab.example.com/ubi7/ubi                          0
  example.com   registry.lab.example.com/ubi8/ubi                          0
  ```

- 添加 `--no-trunc` 选项，可以查看更多的 image 描述：
  **[kiosk@foundation]**

  > VMware `连接网络适配器 2`

  ```bash
  $ nmcli con up ens192
  $ ping -c 4 www.redhat.com
  $ su -
  Asimov
  # scp root@servera:/etc/yum.repos.d/*.repo /etc/yum.repos.d
  # sed -i -e '/nameserver.*172/d' -e '/nameserver/inameserver 172.25.254.250' /etc/resolv.conf
  i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)
  d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚
  -e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。
  #yum module -y install container-tools
  #<Ctrl-D>
  ```

  **[kiosk@foundation]**

```bash
  $ podman login -u `红帽帐号` registry.redhat.io
  Password: `红帽密码`
```

  ```bash
  $ podman search registry.redhat.io/rhel8
  INDEX       NAME                                                DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED
redhat.io   registry.redhat.io/openjdk/openjdk-8-rhel8          OpenJDK 1.8 Image for Java Applications base...   0
  ...
  ```

  ```bash
  $ podman search --no-trunc registry.redhat.io/rhel8
  INDEX       NAME                                                DESCRIPTION                                       STARS   OFFICIAL   AUTOMATED
redhat.io   registry.redhat.io/openjdk/openjdk-8-rhel8         OpenJDK 1.8 Image for Java Applications based on UBI8   0
  ...
  ```

- 下表为一些其他 podman search 命令选项：

  | Option                         | Description                                                  |
  | ------------------------------ | ------------------------------------------------------------ |
  | **--limit \<number>**          | Limits the number of listed images per registry              |
  | **--filter <filter=value>**    | Filters output based on conditions provided. Supported filters include:<br>- **stars=\<number>**: Show only images with at least this number of stars<br>- **is-automated=<true\|false>**: Show only images automatically built<br>- **is-official=<true\|false>**: Show only images flagged as official |
  | **--tls-verify <true\|false>** | Enable or disables HTTPS certificate validation for all used registries. Default=**true** |

```
限制搜索输出个数
docker search redis --limit 5
过滤--filter的使用
stars  收藏星数

docker search --filter stars=3 busybox
IS-AUTOMATED  是否自动构建 

docker search --filter is-automated=true busybox
IS-OFFICIAL  是否官方镜像

docker search --filter is-official=true --filter stars=3 busybox
```

**3.4 使用红帽容器目录（Red Hat Container Catalog）：**

- 红帽维护包含`经过认证的`容器映像的 registry：
  https://access.redhat.com/containers

- 使用这个 registry 可以防范可能由未经测试的映像造成的`已知`漏洞

**3.5 查看容器的 images：**

- 可在将 image 下载到系统之前查看 image 信息。skopeo inspect 命令可以检查 registry 中的远程容器 image 并显示有关它的信息

  ```bash
  $ skopeo inspect docker://registry.redhat.io/rhel8/python-36
  {
      "Name": "registry.redhat.io/rhel8/python-36",
      "Digest": "sha256:ffe84f452974d21370c22008c872730171b0d3f11f89f00aba5c42409d26c6a7",
      "RepoTags": [
      ...
  ```

- 还可使用 podman inspect 检索本地保存的 image 信息，会比 `skopeo inspect` 提供更多信息

  ```bash
  $ podman inspect registry.lab.example.com/ubi7/ubi
  ```

**3.6 删除本地容器图像：**

- 容器映像是只读的。容器的更新意味着 image 的更新

- 当更新后的 image 可用时，发布者更改 latest tag 以将其与新 image 关联。管理员可以删除较旧的 image，pull 最新的 image，并且只使用最新的 image 来运行容器

- 由红帽提供的 image 受益于红帽在管理 RHEL 和其他产品的安全漏洞和缺陷方面的长期经验。红帽安全团队加固这些 images。当发现新的漏洞时，它们将被重新构建，并通过质保流程

- `podman rmi` 移除本地存储的 image

  ```bash
  $ podman images
  
  $ podman ps --all
  $ podman rm d8e3578d277f
  ```

  ```bash
  $ podman rmi registry.lab.example.com/ubi7/ubi
  Untagged: registry.lab.example.com/ubi7/ubi:latest
  Deleted: 87dd8ec61bbc977ed1b2bd29ba089489a8a0281e2e0f62bf43c3fb9c20414194
  ```

  ```bash
  $ podman images
  ```

#### <a name="13.4">第四节：实施高级的容器管理</a>

**目标：**

- 使用选项来运行容器，列出在系统上运行的容器，启动、停止和强制关闭容器

**4.1 用 Podman 管理容器：**

- 可以使用 Podman 运行容器，并管理正在运行或已停止的容器。在本节中，将学习如何使用 Podman 管理容器的整个生命周期
  ![Podman](https://gitee.com/suzhen99/redhat/raw/master/images/Podman.jpg)

  ```bash
  $ podman ps --all
  ```

  ```bash
  $ podman start ce079e808857
  ```

  ```bash
  $ podman ps
  ```

  ```bash
  $ podman stop ce079e808857
  ```

  ```bash
  $ podman ps --all
  ```

**4.2 配置容器：**

- `podman run` 命令从容器 image 启动容器。当运行一个容器时，它将在容器内启动一个进程，可以是一个应用程序，比如web 或数据库服务器
- 要访问容器的网络，`客户端必须连接到容器主机上的端口`，这些端口将网络流量传递到容器中的端口
- 可以向容器传递一些`环境变量`，而不需要修改容器 image

**4.3 将主机端口映射到容器：**

- 当`将容器主机上的网络端口映射到容器中的端口`时，容器将收发到主机端口的网络流量

- 例如，可以将容器主机上的端口 8000 映射到容器上的端口 8080

- podman run -p hostport:containerport 可以映射主机端口到容器

  ```bash
  $ podman run -d -p 8000:8080 registry.lab.example.com/rhel8/httpd-24
  40e4b0d0dce24a853fb7b67e7eb96ee7d8d968925ec04c00e9a9e6532b0c2c9f
  ```

  ```bash
  $ podman ps
  ```

- 可使用 `podman port containerID|name` 来列出端口映射，或使用 `-a` 选项列出所有正在使用的端口映射

  ```bash
  $ podman port -a
  40e4b0d0dce2	8080/tcp -> 0.0.0.0:8000
  -l 查看最后一次出现的
  ```

- 必须确保主机上的`防火墙允许外部客户端连接到它的映射端口`。上例中，可能要在主机上的防火墙规则中添加端口 8000/tcp：

  ```bash
  $ sudo firewall-cmd --permanent --add-port=8000/tcp
  $ sudo firewall-cmd --reload
  ```

**4.4 传递环境变量以配置容器：**

- 可以将环境变量传递给容器，环境变量的值用以配置其应用程序

- `podman inspect` 命令可详细显示容器 image 信息

  ```bash
  $ podman inspect registry.lab.example.com/rhel8/mariadb-103 | egrep '"url|"usage'
                  "url": "https://access.redhat.com/containers/#/registry.access.redhat.com/rhel8/mariadb-103/images/1-102",
                  "usage": "podman run -d -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103",
  ...
  ```

> - **url** 标签指向 [Red Hat Container Catalog](https://access.redhat.com/containers/#/registry.access.redhat.com/rhel8/mariadb-103/images/1-102) 中的一个 web 页面，该页面记录了环境变量和关于如何使用容器 image 的信息
> - **usage** 标签是运行 image 的典型 podman 命令用例
> - 该 image 的 url 标签文档中提供的页面显示容器使用端口 3306，并可以使用以下环境变量来配置数据库服务：
>   - `MYSQL_USER`：MySQL 帐户的用户名
>   - `MYSQL_PASSWORD`：用户帐户的密码
>   - `MYSQL_DATABASE`：数据库名称
>   - `MYSQL_ROOT_PASSWORD`：root 用户的密码（可选）

- `podman run -e` 可以将环境变量传递到容器中

  ```bash
  $ podman run -d --name mydb \
  -e MYSQL_USER=tom \
  -e MYSQL_PASSWORD=mima \
  -e MYSQL_DATABASE=mydb \
  -e MYSQL_ROOT_PASSWORD=redhat \
  -p 3306:3306 registry.lab.example.com/rhel8/mariadb-103
  ```

  > `--name` 选项可为容器分配名称，如果没有设置，podman 将分配一个`随机名称`

**4.5 管理容器：**

- 启动容器只是容器生命周期的第一步。生命周期还包括停止、重启或删除容器。用户还可以检查容器状态和元数据，以便进行调试

- `podman ps` 可以列出运行中的容器

  ```bash
  $ podman ps
  ```

  > 1. 容器 id，16进制，随机生成
  >
  > 2. 容器 image
  >
  > 3. 容器启动时执行的命令
  >
  > 4. 容器创建的时间
  >
  > 5. 容器运行时间
  >
  > 6. 容器暴露的端口或端口映射的信息
  >
  > 7. 容器名称

- `podman ps -a` 命令列出所有容器，包括停止的。podman 并不会删除停止的容器，将保留容器在本地的文件和状态

  ```bash
  $ podman ps -a
  ```

- `podman stop` 命令停止容器运行

  ```bash
  $ podman stop my-httpd-container
  ```

- `podman rm` 在主机上删除容器（需要先停止运行容器）

- `podman rm -f` 可删除正在运行的容器

- `podman rm -a` 删除主机中所有停止运行的容器

  ```bash
  $ podman rm my-database
  ```

- `podman restart` 重新启动一个停止的容器。该命令将创建一个与已停止容器具有相同 ID的新容器，并重用其状态和文件系统

  ```bash
  $ podman restart my-httpd-container
  ```

- `podman kill` 命令发出 Unix SIGKILL 信号，终止容器运行

  ```bash
  $ sudo podman kill my-httpd-container
  ```

**4.6 在容器中运行命令：**

- 容器启动时执行 image 的 entry point 命令。但是，可能需要执行其他命令来管理运行中的容器

- `podman exec` 命令在一个已经运行的容器中启动一个额外的进程：

  ```bash
  $ podman exec 95cbef42ce31 cat /etc/redhat-release
  ```

- 如果希望附加交互式 shell，必须指定 `-it` 选项来打开交互式会话并为 shell 分配一个伪终端

  ```bash
  $ podman exec -it my_webserver /bin/bash
  bash-4.4$ hostname
  bash-4.4$ exit
  ```

- Podman 记得使用的`最后一个容器`。可使用 `-l` 选项在最新的 Podman 命令中替换以前的容器 ID 或名称

  ```bash
  $ podman exec -l cat /etc/redhat-release
  ```



#### <a name="13.5">第五节：为容器附加永久存储</a>

**目标：**

- 通过在运行的容器中挂载目录，以使用容器永久存储（persistent storage）

**5.1 准备永久储存地点：**

- 容器中的存储是短暂的，意味着它的内容在删除容器后会丢失

- 如想在重新启动容器时保留容器使用的数据，临时存储是不够的

- 例如，容器可能是一个数据库服务器，当容器重新启动时，必须保存数据库本身

- 必须为容器提供永久存储

**5.2 从主机提供持久存储：**

- 提供永久存储的一种简单方法是使用`容器主机上的目录`。容器化应用将这些主机目录视为容器存储的一部分。

- 当删除容器时，系统不会回收主机目录中的内容。新容器可以挂载它来访问数据

- 永久存储可以驻留在任何地方，从本地硬盘分区到远程网络文件系统

**5.3 准备主机目录：**

- 在准备主机目录时，必须对其进行配置，`以便容器内的进程能够访问它`。配置包括:
  - `配置目录的所有权和权限`
  - `设置适当的 SELinux context`

- 容器内的`应用程序必须能够访问主机目录`

- 还必须使用适当的SELinux context 配置主机目录（`container_file_t`）。额外的保护将防止在容器内运行的应用程序访问共享目录外的主机文件

- 如果没有来自 SELinux 的额外保护，这些应用程序可能拥有对主机系统上所有文件的根访问权，并且能够危及主机和其他容器

**5.4 卷挂载：**

- 创建并配置主机目录之后，下一步是将该目录挂载到容器中。
  `podman run --volume|-v host_dir:container_dir`

  ```bash
  --volume host_dir:container_dir:z
  ```

- 通过 `Z` 选项，Podman 自动将 SELinux `container_file_t context` 应用到主机目录

  ```bash
  $ mkdir ~/www/html/
  $ echo hello > ~/www/html/index.html
  $ chmod -R o+w ~/www/
  
  $ podman run -d -p 8080:8080 -v /home/student/www:/var/www:Z registry.lab.example.com/rhel8/httpd-24
  
  方法二：（mysql相关）：
  podman run -d --name mydb -v /home/student/my_date:/var/lib/mysql/data:Z  -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -e MYSQL_DATABASE=db -p 3306:3306 rhel8/mariadb-103
  [student@servera /]$ cd /home/student/my_date/
  [student@servera my_date]$ ls
  [student@servera my_date]$ ll -Z /home/student/my_date/ -d
  
  ```



#### <a name="13.6">第六节：以服务方式管理容器</a>

**目标：**

- 以 systemd 服务的方式启动、停止和检查容器

**6.1 服务器启动时自动启动容器**

- 当将数据库或 web 服务器等服务部署为容器时，通常希望这些`容器与服务器一起自动启动`

- 通过为无根（rootless）容器创建 `systemd user unit` 文件，可使用 systemctl 命令来管理它们，类似常规服务

- `通过 enable 这些服务，可以确保容器在主机启动时启动`

- 如果容器以“无根”模式运行，可以非特权用户帐户管理这些服务，以提高安全性

- 要对许多基于容器的应用程序和服务进行更复杂的伸缩和编排，可使用基于 Kubernetes 的企业编排平台，如Red Hat OpenShift Container Platform

**6.2 常规用户运行 Systemd 服务**

- systemd 可以管理 user service，`普通用户可以为自己的服务创建 unit 文件`，并使用systemctl 命令管理这些服务

- 当用户服务类型为非根用户时，通过文本或图形控制台或使用 SSH 打开第一个会话时，该服务将自动启动。当关闭最后一次会话时，服务将停止

- `这种行为与系统服务不同`，系统服务在系统启动时启动，在系统关闭时停止

- 但也可以更改此默认行为，通过运行 `loginctl enable-linger` 命令`强制 service 在服务器启动时启动并在关闭时停止`。逆向操作，请使用 `loginctl disable-linger` 命令

- 查看当前状态，使用 loginctl show-user username 命令

  ```bash
  $ loginctl enable-linger
  $ loginctl show-user user | grep Linger
  Linger=yes
  
  $ loginctl disable-linger
  $ loginctl show-user user | grep Linger
  Linger=no
  ```

**6.3 创建和管理 Systemd User Services：**

- 要定义 systemd user service，创建 `~/.config/systemd/user/` 目录来存储 unit 文件，语法与 system unit file 相同

- 要了解更多细节，请查看 systemd.unit(5) 和 systemd.service(5)

- 要控制新 user service，使用 `systemctl --user` 选项

- 下面的示例列出 ~/.config/systemd/user/ 中的 unit 文件，强制 systemd 重新加载其配置，然后 enable 和 start myapp user service

  ```bash
  $ ls ~/.config/systemd/user/myapp.service
  $ systemctl --user daemon-reload
  $ systemctl --user enable myapp.service
  $ systemctl --user start myapp.service
  ```

  > 更新 podman 版本

  ```bash
  $ podman --version
  podman version 1.6.4
  
  $ sudo wget -P /etc/yum.repos.d/ http://materials/updates.repo
  [sudo] password for student: `student`
  
  $ sudo yum -y update
  
  $ podman --version	# --new支持；开机自启fix
  podman version 1.9.3
  ```

- **注**：要使用 systemctl --user 命令，`必须在控制台登录或直接通过 SSH 登录，不能使用 sudo 或 su 命令`。systemctl 命令与每个用户的 systemd --user 进程交互。只有当用户第一次从控制台或 SSH 登录时，系统才会启动该进程

- 下表总结了 systemd 系统和 user services 之间的区别:

  |                                                |                 System Services                 |                        User services                         |
  | :--------------------------------------------: | :---------------------------------------------: | :----------------------------------------------------------: |
  |         Storing <br>custom unit files          |        /etc/systemd/system/unit.service         |           **~/.config/systemd/user/unit.service**            |
  |              Reloading unit files              |            # systemctl daemon-reload            |            \$ **systemctl --user daemon-reload**             |
  |      Starting and <br>stopping a service       | # systemctl start UNIT<br># systemctl stop UNIT | \$ **systemctl --user start UNIT**<br>\$ **systemctl --user stop UNIT** |
  | Starting a service <br>when the machine starts |             # systemctl enable UNIT             | \$ **loginctl enable-linger**<br>\$ **systemctl --user enable UNIT** |

  

**6.4 使用 Systemd 服务管理容器：**

- 如果容器主机运行少量的容器，可以设置基于用户的 systemd unit 文件，并配置它们以通过自动启动容器

- 这是一种简单的方法，`适用于不需要扩展的小型部署`

- 对于更实际的生产，可以考虑使用 OpenShift

**6.5 创建用于运行容器的专用用户帐户：**

- 为简化无根容器的管理，可以创建一个`专用的用户帐户`，用于管理所有容器

- **注**：为对所有容器进行分组而创建的帐户必须是常规用户帐户。当使用 useradd 创建帐户时，该命令在 /etc/subuid 文件中为用户的容器保留一系列用户 id。但当使用 useradd --system(或 -r)选项创建系统帐户时，该命令不会保留一个范围。因此，不能使用系统帐户启动无根容器

**6.6 创建 Systemd unit 文件**

- 从现有的容器中，`podman 命令可以帮助生成 systemd unit 文件`

- 下面的例子使用 podman generate systemd 命令为现有的 web 容器创建 unit 文件：

  ```bash
  $ cd ~/.config/systemd/user/
  
  $ podman generate systemd --help
  $ podman generate systemd --name web --files --new
  ```

- `podman generate systemd` 命令使用一个容器作为模型来创建配置文件。在创建文件之后，须删除容器

- podman generate systemd 的`选项`：

  - --name container_name：name 选项指定容器的名称，用作模板来生成 unit 文件。Podman 还使用该名称来生成 `unit 文件`的名称：`containers-container_name.service`

  - --files：files 选项指示 Podman 在`当前目录中`生成 unit 文件。如没有这个选项，Podman将在标准输出中显示该文件

  - --new：new 选项指示 Podman 配置 systemd 服务，以便在服务启动时创建容器，并在服务停止时删除。在这种模式下，容器是临时的，通常需要持久存储来保存数据。`没有 --new 选项，Podman 配置服务启动和停止现有的容器，而不删除`

- 下例在运行 podman generate systemd `--new` 时，unit 文件中的开始和停止指令：

  ```bash
  $ podman run -d --name web -p 8080:8080 \
  registry.lab.example.com/rhel8/httpd-24:1-105
  $ podman generate systemd --name web --new
  ```

  1. 启动时，systemd 执行 podman run 命令创建并启动一个新容器

  2. 停止时，systemd 执行 podman stop 命令来停止容器

  3. 当 systemd 关闭了容器，systemd 使用 `podman rm 命令删除容器`

- 相反，下例显示在运行 podman generate systemd 命令时`不带 --new` 选项时的开始和停止指令：

  ```bash
  $ podman run -d --name www -p 8888:8080 \
  registry.lab.example.com/rhel8/httpd-24:1-105
  $ podman generate systemd --name www
  ```

1. 启动时，systemd 执行 podman start 命令来启动已存在的容器
2. 停止时，systemd 执行 podman stop 命令来停止容器。
   `注：systemd 不会删除容器`

**6.7 使用 Systemd 启动和停止容器**

- 使用 systemctl 命令控制容器

  ```bash
  $ systemctl --user start container-web
  $ systemctl --user stop container-web
  $ systemctl --user status container-web
  ```

- 重要：使用 systemctl 命令管理的容器由 systemd 控制。`systemd 监视容器状态，并在它们失败时重新启动它们。不要使用 podman 命令来启动或停止这些容器。`这样做可能会干扰 systemd 监视

**6.8 配置在主机启动时启动的容器**

- 默认情况下，已启用的 systemd user service 在用户打开第一个会话时启动，在用户关闭最后一个会话时停止。
  要让 user service 随服务器自动启动，请运行` loginctl enable-linger` 命令：

  ```bash
  $ loginctl enable-linger
  ```

- 要使容器在主机启动时启动：

  ```bash
  $ systemctl --user enable container-web
  ```

- 要在主机启动时禁用容器启动：

  ```bash
  $ systemctl --user disable container-web
  ```

**6.9 使用 Systemd 管理以 root 运行的容器：**

- 还可以配置希望作为 root 用户运行的容器，以便使用 Systemd unit 文件管理它们

- 优点是可以将这些 unit 文件配置为与普通 unit 单元文件完全相同的工作方式，而不需要一个特定的用户

- 设置这些容器的过程与前面介绍的无根容器类似，不同之处在于:
  - 不需要设置专用用户
  - `当使用 podman generate systemd 创建 unit 文件时，请在 /etc/systemd/system 中运行`，而不是在 ~/.config/systemd/user 中
  - 当用 systemctl 配置容器的服务时，将不会使用 --user 选项
  - 不需要以 root 用户身份运行：loginctl enable-linger

**6.10 规模化编排容器：**

- 在本章学习了如何在单个主机上通过命令行手动配置和管理容器，以及如何配置Systemd 以便容器与服务器一起自动启动。这在很小的范围内非常有用，有助于了解许多关于容器的知识
- 然而，大多数企业需要部署更多容器。Kubernetes 通常用于管理由多个协作容器组成的复杂应用程序
- Red Hat OpenShift 是一个 Kubernetes 平台，它添加了基于 web 的用户界面、监控、在集群中的任何位置运行容器的能力、自动缩放、日志记录和审计等
- 讨论这些工具超出了本课程的范围。如果想了解更多信息，Red Hat 培训还提供了其他课程，从免费的技术概览课程：
  [Deploying Containerized Applications（DO080）](https://www.redhat.com/zh/services/training/do080-deploying-containerized-applications-technical-overview)开始，到 [Introduction to Containers, Kubernetes, and OpenShift（DO180）](https://www.redhat.com/zh/services/training/do180-introduction-containers-kubernetes-red-hat-openshift)。更多信息，请访问 https://www.redhat.com/training 
- 也可以从 https://www.openshift.com了解更多关于 Kubernetes 和 Red Hat OpenShift 的信息



#### <a name="13.l">LAB. containers-review</a>

- 环境准备

**[kiosk@foundation]**

```bash
$ grep -q RHT_COURSE.*rh134 /etc/rht \
  || rht-clearcourse 0 \
  && rht-setcourse rh134
$ for i in classroom bastion utility workstation serverb; do \
  rht-vmctl start $i; sleep 20
  done

$ ping workstaiton
<Ctrl-C>
$ ping serverb
<Ctrl-C>
$ ssh workstation 'lab containers-review start'

Starting lab.

Preparing serverb for lab exercise work:

 · Checking the status of the container registry...............  SUCCESS
 · Creating required user podsvc in serverb ...................  SUCCESS
 · Configuring Yum repository on serverb.......................  SUCCESS
 · Configuring podsvc access to registry on serverb............  SUCCESS
 · Checking that mariadb client is installed on serverb........  SUCCESS
 · Deploying the help files on serverb.........................  SUCCESS
 
 $ ssh podsvc@serverb
```

- Initialize and set some variables

  |  ID  |      ITEM      |                  CONTENT                   |
  | :--: | :------------: | :----------------------------------------: |
  |  1   |     target     |                  serverb                   |
  |  2   |  system_user   |                   podsvc                   |
  |  3   | persistent_dir |            /home/podsvc/db_data            |
  |  4   |     image      | registry.lab.example.com/rhel8/mariadb-103 |
  |  5   |      tag       |                    1-86                    |
  |  6   | container_name |                inventorydb                 |

  |  ID  |        ITEM         |       CONTENT       |
  | :--: | :-----------------: | :-----------------: |
  |  7   |     local_port      |        13306        |
  |  8   |     MYSQL_USER      |      operator1      |
  |  9   |   MYSQL_PASSWORD    |       redhat        |
  |  10  |   MYSQL_DATABASE    |      inventory      |
  |  11  | MYSQL_ROOT_PASSWORD |       redhat        |
  |  12  |       storage       | /var/lib/mysql/data |

- 实验步骤

  **[podsvc@serverb]**

  ```bash
  $ su -
  密码: `redhat`
  # yum module list container*
  # yum module -y install container-tools
  # <Ctrl-D>
  
  $ podman login -u admin -p redhat321
  WARNING! Using --password via the cli is insecure. Please consider using --password-stdin
  Login Succeeded!
  $ podman search registry.lab.example.com/
  INDEX         NAME                                         DESCRIPTION   STARS   OFFICIAL   AUTOMATED
  example.com   `registry.lab.example.com/rhel8/mariadb-103`                 0                  
  example.com   registry.lab.example.com/rhel8/httpd-24                    0                  
  example.com   registry.lab.example.com/library/nginx                     0                  
  example.com   registry.lab.example.com/ubi7/ubi                          0                  
  example.com   registry.lab.example.com/ubi8/ubi                          0
  $ podman pull registry.lab.example.com/rhel·8/mariadb-103
  Trying to pull registry.lab.example.com/rhel8/mariadb-103...
  Getting image source signatures
  Copying blob 77c58f19bd6e done  
  Copying blob 67b9f0b530d9 done  
  Copying blob 47db82df7f3f done  
  Copying blob 71391dc11a78 done  
  Copying config 11a47e0fbe done  
  Writing manifest to image destination
  Storing signatures
  11a47e0fbed05a1f423929778645063f6a9dd6b24251e7e14da9c4b0788fe1e1
  $ podman images
  REPOSITORY                                   TAG      IMAGE ID       CREATED        SIZE
  registry.lab.example.com/rhel8/mariadb-103   latest   11a47e0fbed0   4 months ago   572 MB
  
  $ podman tag 11a47e0fbed0 registry.lab.example.com/rhel8/mariadb-103:1-86
  $ podman images
  REPOSITORY                                   TAG      IMAGE ID       CREATED        SIZE
  registry.lab.example.com/rhel8/mariadb-103   latest   11a47e0fbed0   4 months ago   572 MB
  registry.lab.example.com/rhel8/mariadb-103   1-86     11a47e0fbed0   4 months ago   572 MB
  
  $ mkdir /home/podsvc/db_data
  $ chmod a+rwx db_data
  $ podman run -d \
  --name inventorydb \
  -v /home/podsvc/db_data:/var/lib/mysql/data:z \
  -e MYSQL_USER=operator1 -e MYSQL_PASSWORD=redhat \
  -e MYSQL_DATABASE=inventory -e MYSQL_ROOT_PASSWORD=redhat \
  -p 13306:3306 \
  registry.lab.example.com/rhel8/mariadb-103:1-86
  fb92a1a6b64c13fc882636149e9007e98fb5cb56956e7b1af7b4d973c129ac66
  $ podman ps
  CONTAINER ID  IMAGE                                              COMMAND     CREATED         STATUS             PORTS                    NAMES
  fb92a1a6b64c  registry.lab.example.com/rhel8/mariadb-103:latest  run-mysqld  20 seconds ago  `Up` 18 seconds ago  0.0.0.0:13306->3306/tcp  inventorydb
  $ ss -antup | grep 13306
  tcp    LISTEN  0       128          *:13306        *:*       users:(("exe",pid=28441,fd=12))
  $ mysql -u operator1 -predhat -h serverb -P 13306 -e 'show databases;'
  Database
  information_schema
  inventory
  test
  
  $ mkdir -p .config/systemd/user
  $ cd ~/.config/systemd/user/
  $ podman generate systemd --name inventorydb --files --new
  /home/podsvc/.config/systemd/user/container-inventorydb.service
  
  $ loginctl enable-linger
  $ loginctl show-user podsvc | grep ^L
  Linger=yes
  $ systemctl --user enable container-inventorydb.service
  Created symlink /home/podsvc/.config/systemd/user/multi-user.target.wants/container-inventorydb.service → /home/podsvc/.config/systemd/user/container-inventorydb.service.
  Created symlink /home/podsvc/.config/systemd/user/default.target.wants/container-inventorydb.service → /home/podsvc/.config/systemd/user/container-inventorydb.service.
  ```

- 验证结果

  **[student@workstation]**

  ```bash
  $ lab containers-review grade 
  
  Grading the student\'s work on serverb:
  
   · Required container packages exist...........................  PASS
   · The inventorydb container exists............................  PASS
   · The container is using the correct image....................  PASS
   · The container is using the correct image tag................  PASS
   · The container host port is 13306............................  PASS
   · The database user is operator1..............................  PASS
   · The database password is redhat.............................  PASS
   · The database name is inventory..............................  PASS
   · The database root password is redhat........................  PASS
   · The database uses db_data for storage.......................  PASS
   · The storage is mounted in /var/lib/mysql/data...............  PASS
   · SELinux context is set for db_data..........................  PASS
   · The systemd unit file exists for the container..............  PASS
   · The systemd service for the container is enabled............  PASS
   · The services for podsvc start at boot.......................  PASS
  
  Overall lab grade..............................................  PASS
  ```



#### <a name="13.s">Summary</a>

> - 容器提供了一种轻量级的方式来分发和运行应用程序及其依赖关系，而这些依赖关系可能与主机上安装的软件发生冲突
> - 容器从容器映像运行，您可以从容器注册表下载或自己创建
> - 由 Red Hat Enterprise Linux 提供的 Podman 可在单个主机上直接运行和管理容器以及容器映像
> - 容器可以作为 root 用户运行，也可以作为非特权的无根容器运行，以提高安全性
> - 你可以映射容器主机上的网络端口，以将流量传递到在其容器中运行的服务。
>   您还可以使用环境变量在容器中配置软件
> - 容器存储是临时的，但是你可以使用例如容器主机上目录的内容将持久性存储附加到容器
> - 你可以将 Systemd 配置为在系统启动时自动运行容器



# 第十四章 总复习

## [docker](https://www.docker.com)

![Docker_logo](https://gitee.com/suzhen99/redhat/raw/master/images/Docker_logo.png)



#### d.1 Docker 是什么

> Docker 是一个容器化平台，在这个平台中，我们可以将我们的应用程序与容器中的库和环境绑定在一起

#### d.2 Docker 流程

![Docker Flow](https://gitee.com/suzhen99/redhat/raw/master/images/2074831-20201129203506049-178243366.png)

> 1. Docker 运行在单个进程上，这可能会导致单点故障
> 2. 所有子进程都归属于此进程
> 3. 无论何时，如果 Docker 守护进程失败，所有子进程都会失去跟踪并进入孤立状态
> 4. 安全漏洞
> 5. 对于 Docker 的操作，所有步骤都需要由 root 执行

**[root@foundation]**

1. 卸载 container-tools

```bash
# yum -y module remove container-tools
```

2. 设置 yum 仓库

```bash
wget -P /etc/yum.repos.d https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
sed -i s_download.docker.com_mirrors.aliyun.com/docker-ce_ /etc/yum.repos.d/docker-ce.repo
wget -P /etc/yum.repos.d https://mirrors.aliyun.com/repo/Centos-8.repo
```

3. 安装

```bash
# yum -y install docker-ce docker-ce-cli containerd.io
```

4. 启动

```bash
# systemctl enable --now docker
```

5. 确认

```bash
# docker version
```

6. 设置 docker 仓库

```bash
# cat > /etc/docker/daemon.json <<EOF
{
  "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn","https://hub-mirror.c.163.com"]
}
EOF
# systemctl daemon-reload 
# systemctl restart docker
```

7. 搜索 镜像

```bash
# docker search httpd
```

8. 拉取镜像

```bash
# docker pull httpd
```

9. 查看镜像

```bash
# docker images
```

10. 你准备建立容器

```bash
# mkdir -p /srv/web/
# echo Hello world > /srv/web/index.html
# docker images
```

11. 创立容器，设置端口、持久存储、传参、开机自启

```bash
# docker run -d --name web \
-p 8888:80 \
-v /srv/web:/usr/local/apache2/htdocs:Z \
-e HTTPD_MPM=event \
--restart=always httpd
```

12. 查看建立的容器

```bash
# docker inspect web
```

13. 测试确认

```bash
# docker ps
# curl http://localhost:8888
Hello world

# sync && reboot
```

14. 确认开机自启

```bash
# curl http://localhost:8888
Hello world
```

15. 停止容器

```bash
# docker stop web
```

16. 确认停止

```bash
# docker ps
```

17. 删除容器

```bash
# docker rm web
```

18. 确认删除

```bash
# docker ps --all
```

setcourse

```
【foundation】
rht-clearcourse 0
rht-setcourse rh124
rht-setcourse rh134
rht-setcourse rh294

virt-manager 
```

# RHCSA模拟考试环境布置方法

```bash
考试模拟环境布置方法：
1、恢复init初始环境，启动系统
2、加载ex200软件包，使虚拟机加载软件包镜像
3、以root身份将软件包拷贝到/opt/下 su - root 
4、su - kisok 后 ssh root@localhost 'yum install -y /opt/包名'   （注意不要用其他方式否则报错）
5、安装后，使用exam-setup部署模拟考试环境
6、使用
```

